/* chromium version: 86.0.4240.0 */
Chromium.pfm_title = "Chromium";
Chromium.pfm_description = "Chromium preferences";
AbusiveExperienceInterventionEnforce.pfm_title = "Abusive Experience Intervention Enforce";
AbusiveExperienceInterventionEnforce.pfm_description = "If SafeBrowsingEnabled is not Disabled, then setting AbusiveExperienceInterventionEnforce to Enabled or leaving it unset prevents sites with abusive experiences from opening new windows or tabs.\n\nSetting SafeBrowsingEnabled to Disabled or AbusiveExperienceInterventionEnforce to Disabled lets sites with abusive experiences open new windows or tabs.";
AccessibilityImageLabelsEnabled.pfm_title = "Enable Get Image Descriptions from Google.";
AccessibilityImageLabelsEnabled.pfm_description = "The Get Image Descriptions from Google\naccessibility feature enables visually-impaired screen reader users to\nget descriptions of unlabeled images on the web. Users who choose to enable it\nwill have the option of using an anonymous Google service to provide\nautomatic descriptions for unlabeled images they encounter on the web.\n\nIf this feature is enabled, the content of images will be sent to Google\nservers in order to generate a description. No cookies or other user\ndata is sent, and Google does not save or log any image content.\n\nIf this policy is set to true, the\nGet Image Descriptions from Google\nfeature will be enabled, though it will only affect users who are using a\nscreen reader or other similar assistive technology.\n\nIf this policy is set to false, users will not have the option of enabling\nthe feature.\n\nIf you set this policy, users cannot change or override it.";
AdsSettingForIntrusiveAdsSites.pfm_title = "Ads setting for sites with intrusive ads";
AdsSettingForIntrusiveAdsSites.pfm_description = "1 - Allow ads on all sites\n2 - Do not allow ads on sites with intrusive ads\nUnless SafeBrowsingEnabled is set to False, then setting AdsSettingForIntrusiveAdsSites to 1 or leaving it unset allows ads on all sites.\n\nSetting the policy to 2 blocks ads on sites with intrusive ads.";
AdvancedProtectionAllowed.pfm_title = "Enable additional protections for users enrolled in the Advanced Protection program";
AdvancedProtectionAllowed.pfm_description = "This policy controls whether users enrolled in the Advanced Protection program receive extra protections. Some of these features may involve the sharing of data with Google (for example, Advanced Protection users will be able to send their downloads to Google for malware scanning). If set to True or not set, enrolled users will receive extra protections. If set to False, Advanced Protection users will receive only the standard consumer features.";
AllowCrossOriginAuthPrompt.pfm_title = "Cross-origin HTTP Basic Auth prompts";
AllowCrossOriginAuthPrompt.pfm_description = "Setting the policy to Enabled allows third-party subcontent on a page to open an HTTP Basic Auth pop-up.\n\n Setting the policy to Disabled or leaving it unset renders third-party subcontent unable to open an HTTP Basic Auth pop-up.\n\nTypically, this policy is Disabled as a phishing defense.";
AllowDeletingBrowserHistory.pfm_title = "Enable deleting browser and download history";
AllowDeletingBrowserHistory.pfm_description = "Setting the policy to Enabled or leaving it unset means browser history and download history can be deleted in Chrome, and users can't change this setting.\n\nSetting the policy to Disabled means browser history and download history can't be deleted. Even with this policy off, the browsing and download history are not guaranteed to be retained. Users may be able to edit or delete the history database files directly, and the browser itself may expire or archive any or all history items at any time.";
AllowDinosaurEasterEgg.pfm_title = "Allow Dinosaur Easter Egg Game";
AllowDinosaurEasterEgg.pfm_description = "Setting the policy to True allows users to play the dinosaur game. Setting the policy to False means users can't play the dinosaur easter egg game when device is offline.\n\nLeaving the policy unset means users can't play the game on enrolled Chromium OS, but can under other circumstances.";
AllowFileSelectionDialogs.pfm_title = "Allow invocation of file selection dialogs";
AllowFileSelectionDialogs.pfm_description = "Setting the policy or leaving it unset means Chrome can display, and users can open, file selection dialogs.\n\nTurning off the policy means that whenever users perform actions provoking a file selection dialog, such as importing bookmarks, uploading files, and saving links, a message appears instead. The user is assumed to have clicked Cancel on the file selection dialog.";
AllowOutdatedPlugins.pfm_title = "Allow running plugins that are outdated";
AllowOutdatedPlugins.pfm_description = "Setting the policy to Enabled means outdated plugins are used as normal plugins. Setting the policy to Disabled means outdated plugins aren't used.\n\nLeaving the policy unset means users will be asked for permission to run outdated plugins.";
AllowPopupsDuringPageUnload.pfm_title = "Allows a page to show popups during its unloading";
AllowPopupsDuringPageUnload.pfm_description = "Setting the policy to True allows pages to show pop-ups while the pages unload.\n\nSetting the policy to False or leaving it unset prevents pages from showing pop-ups while the pages unload.\n\nThis policy will be removed in Chrome 88.\n\nSee https://www.chromestatus.com/feature/5989473649164288.";
AllowSyncXHRInPageDismissal.pfm_title = "Allows a page to perform synchronous XHR requests during page dismissal.";
AllowSyncXHRInPageDismissal.pfm_description = "This policy allows an admin to specify that a page may send synchronous XHR requests during page dismissal.\n\nWhen the policy is set to enabled, pages are allowed to send synchronous XHR requests during page dismissal.\n\nWhen the policy is set to disabled or not set, pages are not allowed to send synchronous XHR requests during page dismissal.\n\nThis policy will be removed in Chrome 88.\n\nSee https://www.chromestatus.com/feature/4664843055398912 .";
AllowedDomainsForApps.pfm_title = "Define domains allowed to access G Suite";
AllowedDomainsForApps.pfm_description = "Setting the policy turns on Chrome's restricted sign-in feature in G Suite and prevents users from changing this setting. Users can only access Google tools using accounts from the specified domains (to allow gmail or googlemail accounts, add consumer_accounts to the list of domains). This setting prevents users from signing in and adding a Secondary Account on a managed device that requires Google authentication, if that account doesn't belong to one of the explicitly allowed domains.\n\nLeaving this setting empty or unset means users can access G Suite with any account.\n\nUsers cannot change or override this setting.\n\nNote: This policy causes the X-GoogApps-Allowed-Domains header to be appended to all HTTP and HTTPS requests to all google.com domains, as described in https://support.google.com/a/answer/1668854.";
AlternateErrorPagesEnabled.pfm_title = "Enable alternate error pages";
AlternateErrorPagesEnabled.pfm_description = "Setting the policy to True means Chromium uses alternate error pages built into (such as \"page not found\"). Setting the policy to False means Chromium never uses alternate error pages.\n\nIf you set the policy, users can't change it. If not set, the policy is on, but users can change this setting.";
AlternativeBrowserParameters.pfm_title = "Command-line parameters for the alternative browser.";
AlternativeBrowserParameters.pfm_description = "Setting the policy to a list of strings means each string is passed to the alternative browser as separate command-line parameters. On Microsoft® Windows®, the parameters are joined with spaces. On macOS and Linux®, a parameter can have spaces and still be treated as a single parameter.\n\nIf an parameter contains ${url}, ${url} is replaced with the URL of the page to open. If no parameter contains ${url}, the URL is appended at the end of the command line.\n\nEnvironment variables are expanded. On Microsoft® Windows®, %ABC% is replaced with the value of the ABC environment variable. On macOS and Linux®, ${ABC} is replaced with the value of the ABC environment variable.\n\nLeaving the policy unset means only the URL is passed as a command-line parameter.";
AlternativeBrowserPath.pfm_title = "Alternative browser to launch for configured websites.";
AlternativeBrowserPath.pfm_description = "Setting the policy controls which command to use to open URLs in an alternative browser. The policy can be set to one of ${ie}, ${firefox}, ${safari}, ${opera} or a file path. When this policy is set to a file path, that file is used as an executable file. ${ie} is only available on Microsoft® Windows®, and ${safari} is only available on Microsoft® Windows® and macOS.\n\nLeaving the policy unset puts a platform-specific default in use: Internet Explorer® for Microsoft® Windows®, or Safari® for macOS. On Linux®, launching an alternative browser will fail.";
AlwaysOpenPdfExternally.pfm_title = "Always Open PDF files externally";
AlwaysOpenPdfExternally.pfm_description = "Setting the policy to True turns the internal PDF viewer off in Chromium, treats PDF files as a download, and lets users open PDFs with the default application.\n\nSetting the policy to False or leaving it unset means that unless users turns off the PDF plugin, it will open PDF files.";
AmbientAuthenticationInPrivateModesEnabled.pfm_title = "Enable Ambient Authentication for profile types.";
AmbientAuthenticationInPrivateModesEnabled.pfm_description = "0 - Enable ambient authentication in regular sessions only.\n1 - Enable ambient authentication in incognito and regular sessions.\n2 - Enable ambient authentication in guest and regular sessions.\n3 - Enable ambient authentication in regular, incognito and guest sessions.\nConfiguring this policy will allow/disallow ambient authentication for Incognito and Guest profiles in Chromium.\n\nAmbient Authentication is http authentication with default credentials if explicit credentials are not provided via NTLM/Kerberos/Negotiate challenge/response schemes.\n\nSetting the RegularOnly (value 0), allows ambient authentication for Regular sessions only. Incognito and Guest sessions wouldn't be allowed to ambiently authenticate.\n\nSetting the IncognitoAndRegular (value 1), allows ambient authentication for Incognito and Regular sessions. Guest sessions wouldn't be allowed to ambiently authenticate.\n\nSetting the GuestAndRegular (value 2), allows ambient authentication for Guest and Regular sessions. Incognito sessions wouldn't be allowed to ambiently authenticate.\n\nSetting the  All (value 3), allows ambient authentication for all sessions.\n\nNote that, ambient authentication is always allowed on regular profiles.\n\nIn Chromium version 81 and later, if the policy is left not set, ambient authentication will be enabled in regular sessions only.";
AppCacheForceEnabled.pfm_title = "Allows the AppCache feature to be re-enabled even if it is off by default.";
AppCacheForceEnabled.pfm_description = "If set to true, this will force AppCache to be enabled, even when AppCache in Chrome is not available by default.\n\nIf unset or set to false, AppCache will follow Chrome's defaults.";
AudioCaptureAllowed.pfm_title = "Allow or deny audio capture";
AudioCaptureAllowed.pfm_description = "Setting the policy to Enabled or leaving it unset means that, with the exception of URLs set in the AudioCaptureAllowedUrls list, users get prompted for audio capture access.\n\nSetting the policy to Disabled turns off prompts, and audio capture is only available to URLs set in the AudioCaptureAllowedUrls list.\n\nNote: The policy affects all audio input (not just the built-in microphone).";
AudioCaptureAllowedUrls.pfm_title = "URLs that will be granted access to audio capture devices without prompt";
AudioCaptureAllowedUrls.pfm_description = "Setting the policy means you specify the URL list whose patterns get matched to the security origin of the requesting URL. A match grants access to audio capture devices without prompt\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
AudioSandboxEnabled.pfm_title = "Allow the audio sandbox to run";
AudioSandboxEnabled.pfm_description = "This policy controls the audio process sandbox.\nIf this policy is enabled, the audio process will run sandboxed.\nIf this policy is disabled, the audio process will run unsandboxed and the WebRTC audio-processing module will run in the renderer process.\nThis leaves users open to security risks related to running the audio subsystem unsandboxed.\nIf this policy is not set, the default configuration for the audio sandbox will be used, which may differ per platform.\nThis policy is intended to give enterprises flexibility to disable the audio sandbox if they use security software setups that interfere with the sandbox.";
AuthNegotiateDelegateAllowlist.pfm_title = "Kerberos delegation server allowlist";
AuthNegotiateDelegateAllowlist.pfm_description = "Setting the policy assigns servers that Chromium may delegate to. Separate multiple server names with commas. Wildcards, *, are allowed.\n\nLeaving the policy unset means Chromium won't delegate user credentials, even if a server is detected as intranet.";
AuthNegotiateDelegateByKdcPolicy.pfm_title = "Use KDC policy to delegate credentials.";
AuthNegotiateDelegateByKdcPolicy.pfm_description = "Setting the policy to Enabled means HTTP authentication respects approval by KDC policy. In other words, Chromium delegates user credentials to the service being accessed if the KDC sets OK-AS-DELEGATE on the service ticket. See RFC 5896 ( https://tools.ietf.org/html/rfc5896.html ). The service should also be allowed by AuthNegotiateDelegateAllowlist.\n\nSetting the policy to Disabled or leaving it unset means KDC policy is ignored on supported platforms and only AuthNegotiateDelegateAllowlist is respected.\n\nOn Microsoft® Windows®, KDC policy is always respected.";
AuthSchemes.pfm_title = "Supported authentication schemes";
AuthSchemes.pfm_description = "Setting the policy specifies which HTTP authentication schemes Chromium supports.\n\nLeaving the policy unset employs all 4 schemes.\n\nValid values:\n\n* basic\n\n* digest\n\n* ntlm\n\n* negotiate\n\nNote: Separate multiple values with commas.";
AuthServerAllowlist.pfm_title = "Authentication server allowlist";
AuthServerAllowlist.pfm_description = "Setting the policy specifies which servers should be allowed for integrated authentication. Integrated authentication is only on when Chromium gets an authentication challenge from a proxy or from a server in this permitted list.\n\nLeaving the policy unset means Chromium tries to detect if a server is on the intranet. Only then will it respond to IWA requests. If a server is detected as internet, then Chromium ignores IWA requests from it.\n\nNote: Separate multiple server names with commas. Wildcards, *, are allowed.";
AutoLaunchProtocolsFromOrigins.pfm_title = "Define a list of protocols that can launch an external application from listed origins without prompting the user";
AutoLaunchProtocolsFromOrigins.pfm_description = "Allows you to set a list of protocols, and for each protocol an associated list of allowed origin patterns, that can launch an external application without prompting the user. The trailing separator should not be included when listing the protocol, so list \"skype\" instead of \"skype:\" or \"skype://\".\n\nIf this policy is set, a protocol will only be permitted to launch an external application without prompting by policy if the protocol is listed, and the origin of the site trying to launch the protocol matches one of the origin patterns in that protocol's allowed_origins list. If either condition is false the external protocol launch prompt will not be omitted by policy.\n\nIf this policy is not set, no protocols can launch without a prompt by default. Users may opt out of prompts on a per-protocol/per-site basis unless the ExternalProtocolDialogShowAlwaysOpenCheckbox policy is set to Disabled. This policy has no impact on per-protocol/per-site prompt exemptions set by users.\n\nThe origin matching patterns use a similar format to those for the 'URLBlocklist' policy, which are documented at http://www.chromium.org/administrators/url-blacklist-filter-format.\n\nHowever, origin matching patterns for this policy cannot contain \"/path\" or \"@query\" elements. Any pattern that does contain a \"/path\" or \"@query\" element will be ignored.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=AutoLaunchProtocolsFromOrigins for more information about schema and formatting.";
AutoOpenAllowedForURLs.pfm_title = "URLs where AutoOpenFileTypes can apply";
AutoOpenAllowedForURLs.pfm_description = "List of URLs specifying which urls AutoOpenFileTypes will apply to. This policy has no impact on automatically open values set by users.\n\nIf this policy is set, files will only automatically open by policy if the url is part of this set and the file type is listed in AutoOpenFileTypes. If either condition is false the download won't automatically open by policy.\n\nIf this policy isn't set, all downloads where the file type is in AutoOpenFileTypes will automatically open.\n\nA URL pattern has to be formatted according to https://www.chromium.org/administrators/url-blacklist-filter-format.";
AutoOpenFileTypes.pfm_title = "List of file types that should be automatically opened on download";
AutoOpenFileTypes.pfm_description = "List of file types that should be automatically opened on download. The leading separator should not be included when listing the file type, so list \"txt\" instead of \".txt\".\n\nFiles with types that should be automatically opened will still be subject to the enabled safe browsing checks and won't be opened if they fail those checks.\n\nIf this policy isn't set, only file types that a user has already specified to automatically be opened will do so when downloaded.\n\nOn Microsoft® Windows®, this functionality is only available on instances that are joined to a Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this functionality is only available on instances that are managed via MDM, or joined to a domain via MCX.";
AutoSelectCertificateForUrls.pfm_title = "Automatically select client certificates for these sites";
AutoSelectCertificateForUrls.pfm_description = "Setting the policy lets you make a list of URL patterns that specify sites for which Chrome can automatically select a client certificate. The value is an array of stringified JSON dictionaries, each with the form { \"pattern\": \"$URL_PATTERN\", \"filter\" : $FILTER }, where $URL_PATTERN is a content setting pattern. $FILTER restricts the client certificates the browser automatically selects from. Independent of the filter, only certificates that match the server's certificate request are selected.\n\nExamples for the usage of the $FILTER section:\n\n* When $FILTER is set to { \"ISSUER\": { \"CN\": \"$ISSUER_CN\" } }, only client certificates issued by a certificate with the CommonName $ISSUER_CN are selected.\n\n* When $FILTER contains both the \"ISSUER\" and the \"SUBJECT\" sections, only client certificates that satisfy both conditions are selected.\n\n* When $FILTER contains a \"SUBJECT\" section with the \"O\" value, a certificate needs at least one organization matching the specified value to be selected.\n\n* When $FILTER contains a \"SUBJECT\" section with a \"OU\" value, a certificate needs at least one organizational unit matching the specified value to be selected.\n\n* When $FILTER is set to {}, the selection of client certificates is not additionally restricted. Note that filters provided by the web server still apply.\n\nLeaving the policy unset means there's no autoselection for any site.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=AutoSelectCertificateForUrls for more information about schema and formatting.";
AutofillAddressEnabled.pfm_title = "Enable AutoFill for addresses";
AutofillAddressEnabled.pfm_description = "Setting the policy to True or leaving it unset gives users control of Autofill for addresses in the UI.\n\nSetting the policy to False means Autofill never suggests or fills address information, nor does it save additional address information that users submit while browsing the web.";
AutofillCreditCardEnabled.pfm_title = "Enable AutoFill for credit cards";
AutofillCreditCardEnabled.pfm_description = "Setting the policy to True or leaving it unset means users can control autofill suggestions for credit cards in the UI.\n\nSetting the policy to False means autofill never suggests or fills credit card information, nor will it save additional credit card information that users might submit while browsing the web.";
AutoplayAllowed.pfm_title = "Allow media autoplay";
AutoplayAllowed.pfm_description = "Setting the policy to True lets Chromium autoplay media. Setting the policy to False stops Chromium from autoplaying media.\n\n By default, Chromium doesn't autoplay media. But, for certain URL patterns, you can use the AutoplayAllowlist policy to change this setting.\n\nIf this policy changes while Chromium is running, it only applies to newly opened tabs.";
AutoplayAllowlist.pfm_title = "Allow media autoplay on a whitelist of URL patterns";
AutoplayAllowlist.pfm_description = "Setting the policy lets videos play automatically (without user consent) with audio content in Chromium. If AutoplayAllowed policy is set to True, then this policy has no effect. If AutoplayAllowed is set to False, then any URL patterns set in this policy can still play. If this policy changes while Chromium is running, it only applies to newly opened tabs.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
BlockExternalExtensions.pfm_title = "Blocks external extensions from being installed";
BlockExternalExtensions.pfm_description = "Controls external extensions installation.\n\nEnabling this setting blocks external extensions from being installed.\n\nDisabling this setting or leaving it unset allows external extensions to be installed.\n\nExternal extensions and their installation are documented at https://developer.chrome.com/apps/external_extensions.\n";
BlockThirdPartyCookies.pfm_title = "Block third party cookies";
BlockThirdPartyCookies.pfm_description = "Setting the policy to True prevents webpage elements that aren't from the domain that's in the browser's address bar from setting cookies. Setting the policy to False lets those elements set cookies and prevents users from changing this setting.\n\nLeaving it unset turns third-party cookies on, but users can change this setting.";
BookmarkBarEnabled.pfm_title = "Enable Bookmark Bar";
BookmarkBarEnabled.pfm_description = "Setting the policy to True displays a bookmark bar in Chromium. Setting the policy to False means users never see the bookmark bar.\n\nIf you set the policy, users can't change it. If not set, users decide whether to use this function.";
BrowserAddPersonEnabled.pfm_title = "Enable add person in user manager";
BrowserAddPersonEnabled.pfm_description = "If this policy is set to true or not configured, Chromium will allow Add Person from the user manager.\n\nIf this policy is set to false, Chromium will not allow creation of new profiles from the user manager.";
BrowserGuestModeEnabled.pfm_title = "Enable guest mode in browser";
BrowserGuestModeEnabled.pfm_description = "If this policy is set to true or not configured, Chromium will enable guest logins. Guest logins are Chromium profiles where all windows are in incognito mode.\n\nIf this policy is set to false, Chromium will not allow guest profiles to be started.";
BrowserGuestModeEnforced.pfm_title = "Enforce browser guest mode";
BrowserGuestModeEnforced.pfm_description = "If this policy is set to enabled, Chromium will enforce guest sessions and prevents profile logins. Guest logins are Chromium profiles where all windows are in incognito mode.\n\nIf this policy is set to disabled or not set or browser guest mode is disabled by BrowserGuestModeEnabled policy, Chromium will allow using new and existing profiles.";
BrowserNetworkTimeQueriesEnabled.pfm_title = "Allow queries to a Google time service";
BrowserNetworkTimeQueriesEnabled.pfm_description = "Setting this policy to false stops Chromium from occasionally sending queries to a Google server to retrieve an accurate timestamp. These queries will be enabled if this policy is set to True or is not set.";
BrowserSignin.pfm_title = "Browser sign in settings";
BrowserSignin.pfm_description = "0 - Disable browser sign-in\n1 - Enable browser sign-in\n2 - Force users to sign-in to use the browser\nThis policy controls the sign-in behavior of the browser. It allows you to specify if the user can sign in to Chromium with their account and use account related services like Chrome sync.\n\nIf the policy is set to \"Disable browser sign-in\" then the user can not sign in to the browser and use account based services. In this case browser level features like Chrome sync can not be used and will be unavailable. If the user was signed in and the policy is set \"Disabled\" they will be signed out the next time they run Chrome but their local profile data like bookmarks, passwords etc. will stay preserved. The user will still be able to sign into and use Google web services like Gmail.\n\nIf the policy is set to \"Enable browser sign-in,\" then the user is allowed to sign in to the browser and is automatically signed in to the browser when signed in to Google web services like Gmail. Being signed in to the browser means the user's account information will be kept by the browser. However, it does not mean that Chrome sync will be turned on per default; the user must separately opt-in to use this feature. Enabling this policy will prevent the user from turning off the setting that allows browser sign-in. To control the availability of Chrome sync, use the \"SyncDisabled\" policy.\n\nIf the policy is set to \"Force browser sign-in\" the user is presented with an account selection dialog and has to choose and sign in to an account to use the browser. This ensures that for managed accounts the policies associated with the account are applied and enforced. By default this turns on Chrome sync for the account, except for the case when sync was disabled by the domain admin or via the \"SyncDisabled\" policy. The default value of BrowserGuestModeEnabled will be set to false. Note that existing unsigned profiles will be locked and inaccessible after enabling this policy. For more information, see help center article: https://support.google.com/chrome/a/answer/7572556. This option does not support Linux and Android, it will fallback to \"Enable browser sign-in\" if used.\n\nIf this policy is not set then the user can decide if they want to enable the browser sign in option and use it as they see fit.";
BrowserSwitcherDelay.pfm_title = "Delay before launching alternative browser (milliseconds)";
BrowserSwitcherDelay.pfm_description = "Setting the policy to a number has Chromium show a message for that number of milliseconds, then it opens an alternative browser.\n\nLeaving the policy unset or set to 0 means navigating to a designated URL immediately opens it in an alternative browser.";
BrowserSwitcherEnabled.pfm_title = "Enable the Legacy Browser Support feature.";
BrowserSwitcherEnabled.pfm_description = "Setting the policy to Enabled means Chromium will try to launch some URLs in an alternate browser, such as Internet Explorer®. This feature is set using the policies in the Legacy Browser support group.\n\nSetting the policy to Disabled or leaving it unset means Chromium won't try to launch designated URLs in an alternate browser.";
BrowserSwitcherExternalGreylistUrl.pfm_title = "URL of an XML file that contains URLs that should never trigger a browser switch.";
BrowserSwitcherExternalGreylistUrl.pfm_description = "Setting the policy to a valid URL has Chromium download the site list from that URL and apply the rules as if they were set up with the BrowserSwitcherUrlGreylist policy. These policies prevent Chromium and the alternative browser from opening one another.\n\nLeaving it unset (or set to a invalid URL) means Chromium doesn't use the policy as a source of rules for not switching browsers.\n\nNote: This policy points to an XML file in the same format as Internet Explorer®'s SiteList policy. This loads rules from an XML file, without sharing those rules with Internet Explorer®. Read more on Internet Explorer®'s SiteList policy ( https://docs.microsoft.com/internet-explorer/ie11-deploy-guide/what-is-enterprise-mode )";
BrowserSwitcherExternalSitelistUrl.pfm_title = "URL of an XML file that contains URLs to load in an alternative browser.";
BrowserSwitcherExternalSitelistUrl.pfm_description = "Setting the policy to a valid URL has Chromium download the site list from that URL and apply the rules as if they were set up with the BrowserSwitcherUrlList policy.\n\nLeaving it unset (or set to a invalid URL) means Chromium doesn't use the policy as a source of rules for switching browsers.\n\nNote: This policy points to an XML file in the same format as Internet Explorer®'s SiteList policy. This loads rules from an XML file, without sharing those rules with Internet Explorer®. Read more on Internet Explorer®'s SiteList policy ( https://docs.microsoft.com/internet-explorer/ie11-deploy-guide/what-is-enterprise-mode)";
BrowserSwitcherKeepLastChromeTab.pfm_title = "Keep last tab open in Chrome.";
BrowserSwitcherKeepLastChromeTab.pfm_description = "Setting the policy to Enabled or leaving it unset has Chromium keep at least one tab open, after switching to an alternate browser.\n\nSetting the policy to Disabled has Chromium close the tab after switching to an alternate browser, even if it was the last tab. This causes Chromium to exit completely.";
BrowserSwitcherUrlGreylist.pfm_title = "Websites that should never trigger a browser switch.";
BrowserSwitcherUrlGreylist.pfm_description = "Setting the policy controls the list of websites that will never cause a browser switch. Each item is treated as a rule. Those rules that match won't open an alternative browser. Unlike the BrowserSwitcherUrlList policy, rules apply to both directions. When the Internet Explorer® add-in is on, it also controls whether Internet Explorer® should open these URLs in Chromium.\n\nLeaving the policy unset adds no websites to the list.\n\nNote: Elements can also be added to this list through the BrowserSwitcherExternalGreylistUrl policy.";
BrowserSwitcherUrlList.pfm_title = "Websites to open in alternative browser";
BrowserSwitcherUrlList.pfm_description = "Setting the policy controls the list of websites to open in an alternative browser. Each item is treated as a rule for something to open in an alternative browser. Chromium uses those rules when choosing if a URL should open in an alternative browser. When the Internet Explorer® add-in is on, Internet Explorer® switches back to Chromium when the rules don't match. If rules contradict each other, Chromium uses the most specific rule.\n\nLeaving the policy unset adds no websites to the list.\n\nNote: Elements can also be added to this list through the BrowserSwitcherUseIeSitelist and BrowserSwitcherExternalSitelistUrl policies.";
BuiltInDnsClientEnabled.pfm_title = "Use built-in DNS client";
BuiltInDnsClientEnabled.pfm_description = "Controls whether the built-in DNS client is used in Chromium.\n\nThis does not affect which DNS servers are used; just the software stack which is used to communicate with them. For example if the operating system is configured to use an enterprise DNS server, that same server would be used by the built-in DNS client. It is however possible that the built-in DNS client will address servers in different ways by using more modern DNS-related protocols such as DNS-over-TLS.\n\nIf this policy is set to true, the built-in DNS client will be used, if available.\n\nIf this policy is set to false, the built-in DNS client will never be used.\n\nIf this policy is left not set, the built-in DNS client will be enabled by default on macOS, Android (when neither Private DNS nor VPN are enabled) and ChromeOS, and the users will be able to change whether the built-in DNS client is used by editing chrome://flags or specifying a command-line flag.";
BuiltinCertificateVerifierEnabled.pfm_title = "Determines whether the built-in certificate verifier will be used to verify server certificates";
BuiltinCertificateVerifierEnabled.pfm_description = "When this setting is enabled, Chromium will perform verification of server certificates using the built-in certificate verifier.\nWhen this setting is disabled, Chromium will perform verification of server certificates using the legacy certificate verifier provided by the platform.\nWhen this setting is not set, the built-in or the legacy certificate verifier may be used.\n\nThis policy is planned to be removed in Chromium OS version 81, when support for the legacy certificate verifier on Chromium OS is planned to be removed.\n\nThis policy is planned to be removed in Chromium for Linux version 83, when support for the legacy certificate verifier on Linux is planned to be removed.\n\nThis policy is planned to be removed in Chromium for Mac OS X version 87, when support for the legacy certificate verifier on Mac OS X is planned to be removed.\n";
CertificateTransparencyEnforcementDisabledForCas.pfm_title = "Disable Certificate Transparency enforcement for a list of subjectPublicKeyInfo hashes";
CertificateTransparencyEnforcementDisabledForCas.pfm_description = "Setting the policy turns off enforcement of Certificate Transparency disclosure requirements for a list of subjectPublicKeyInfo hashes. Enterprise hosts can keep using certificates that otherwise wouldn't be trusted (because they weren't properly publicly disclosed). To turn off enforcement, the hash must meet one of these conditions:\n\n* It's of the server certificate's subjectPublicKeyInfo.\n\n* It's of a subjectPublicKeyInfo that appears in a Certificate Authority (CA) certificate in the certificate chain. That CA certificate is constrained through the X.509v3 nameConstraints extension, one or more directoryName nameConstraints are present in the permittedSubtrees, and the directoryName has an organizationName attribute.\n\n* It's of a subjectPublicKeyInfo that appears in a CA certificate in the certificate chain, the CA certificate has one or more organizationName attributes in the certificate Subject, and the server's certificate has the same number of organizationName attributes, in the same order, and with byte-for-byte identical values.\n\nSpecify a subjectPublicKeyInfo hash by linking the hash algorithm name, a slash, and the Base64 encoding of that hash algorithm applied to the DER-encoded subjectPublicKeyInfo of the specified certificate. Base64 encoding format matches that of an SPKI Fingerprint. The only recognized hash algorithm is sha256; others are ignored.\n\nLeaving the policy unset means that if certificates requiring disclosure through Certificate Transparency aren't disclosed, then Chromium doesn't trust those certificates.";
CertificateTransparencyEnforcementDisabledForLegacyCas.pfm_title = "Disable Certificate Transparency enforcement for a list of Legacy Certificate Authorities";
CertificateTransparencyEnforcementDisabledForLegacyCas.pfm_description = "Setting the policy turns off enforcement of Certificate Transparency disclosure requirements for a list of Legacy Certificate Authorities (CA) for certificate chains with a specified subjectPublicKeyInfo hash. Enterprise hosts can keep using certificates that otherwise wouldn't be trusted (because they weren't properly publicly disclosed). To turn off enforcement, the subjectPublicKeyInfo hash must appear in a CA certificate recognized as a Legacy CA. A Legacy CA is publicly trusted by one or more operating systems supported by Chromium, but not Android Open Source Project or Chromium OS.\n\nSpecify a subjectPublicKeyInfo hash by linking the hash algorithm name, a slash and the Base64 encoding of that hash algorithm applied to the DER-encoded subjectPublicKeyInfo of the specified certificate. Base64 encoding format matches that of an SPKI Fingerprint. The only recognized hash algorithm is sha256; others are ignored.\n\nLeaving the policy unset means that if certificates requiring disclosure through Certificate Transparency aren't disclosed, then Chromium doesn't trust those certificates.";
CertificateTransparencyEnforcementDisabledForUrls.pfm_title = "Disable Certificate Transparency enforcement for a list of URLs";
CertificateTransparencyEnforcementDisabledForUrls.pfm_description = "Setting the policy turns off Certificate Transparency disclosure requirements for the hostnames in the specified URLs. While making it harder to detect misissued certificates, hosts can keep using certificates that otherwise wouldn't be trusted (because they weren't properly publicly disclosed).\n\nLeaving the policy unset means that if certificates requiring disclosure through Certificate Transparency aren't disclosed, then Chromium doesn't trust those certificates.\n\nA URL pattern follows this format ( https://www.chromium.org/administrators/url-blacklist-filter-format ). However, because the validity of certificates for a given hostname is independent of the scheme, port, or path, Chromium only considers the hostname portion of the URL. Wildcard hosts aren't supported.";
ChromeVariations.pfm_title = "Determine the availability of variations";
ChromeVariations.pfm_description = "0 - Enable all variations\n1 - Enable variations concerning critical fixes only\n2 - Disable all variations\nConfiguring this policy allows to specify which variations are allowed to be applied in Chromium.\n\nVariations provide a means for offering modifications to Chromium without shipping a new version of the browser by selectively enabling or disabling already existing features. See https://support.google.com/chrome/a?p=Manage_the_Chrome_variations_framework for more information.\n\nSetting the VariationsEnabled (value 0), or leaving the policy not set allows all variations to be applied to the browser.\n\nSetting the CriticalFixesOnly (value 1), allows only variations considered critical security or stability fixes to be applied to Chromium.\n\nSetting the VariationsDisabled (value 2), prevent all variations from being applied to the browser. Please note that this mode can potentially prevent the Chromium developers from providing critical security fixes in a timely manner and is thus not recommended.";
ClickToCallEnabled.pfm_title = "Enable the Click to Call Feature";
ClickToCallEnabled.pfm_description = "Enable the Click to Call feature which allows users to send phone numbers from Chrome Desktops to an Android device when the user is Signed-in. For more information, see help center article: https://support.google.com/chrome/answer/9430554?hl=en.\n\nIf this policy is set to enabled, the capability of sending phone numbers to Android devices will be enabled for the Chrome user.\n\nIf this policy is set to disabled, the capability of sending phone numbers to Android devices will be disabled for the Chrome user.\n\nIf you set this policy, users cannot change or override it.\n\nIf this policy is left unset, the Click to Call feature is enabled by default.";
CloudManagementEnrollmentMandatory.pfm_title = "Enable mandatory cloud management enrollment";
CloudManagementEnrollmentMandatory.pfm_description = "\nIf this policy is set to True, cloud management enrollment is mandatory and blocks Chrome launch process if failed.\n\nIf this policy is left unset or set to False, cloud management enrollment is optional and does not blocks Chrome launch process if failed.\n\nThis policy is used by machine scope cloud policy enrollment on desktop and can be set by Registry or GPO on Windows, plist on Mac and JSON policy file on Linux.";
CloudManagementEnrollmentToken.pfm_title = "The enrollment token of cloud policy on desktop";
CloudManagementEnrollmentToken.pfm_description = "\nIf this policy is set, Chromium will try to register itself and apply associated cloud policy for all profiles.\n\nThe value of this policy is an Enrollment token that can be retrieved from the Google Admin console.";
CloudPolicyOverridesPlatformPolicy.pfm_title = "Chromium cloud policy overrides Platform policy.";
CloudPolicyOverridesPlatformPolicy.pfm_description = "\nIf the policy is set to true, cloud policy takes precedence if it conflicts with platform policy.\nIf the policy is set to false or not configured, platform policy takes precedence if it conflicts with cloud policy.\n\nThis policy is only available as a mandatory machine platform policy and it only affects machine scope cloud policies.\n";
CloudPrintProxyEnabled.pfm_title = "Enable Google Cloud Print proxy";
CloudPrintProxyEnabled.pfm_description = "Enables Chromium to act as a proxy between Google Cloud Print and legacy printers connected to the machine.\n\nIf this setting is enabled or not configured, users can enable the cloud print proxy by authentication with their Google account.\n\nIf this setting is disabled, users cannot enable the proxy, and the machine will not be allowed to share it's printers with Google Cloud Print.";
CloudPrintSubmitEnabled.pfm_title = "Enable submission of documents to Google Cloud Print";
CloudPrintSubmitEnabled.pfm_description = "Enables Chromium to submit documents to Google Cloud Print for printing.  NOTE: This only affects Google Cloud Print support in Chromium.  It does not prevent users from submitting print jobs on web sites.\n\nIf this setting is enabled or not configured, users can print to Google Cloud Print from the Chromium print dialog.\n\nIf this setting is disabled, users cannot print to Google Cloud Print from the Chromium print dialog.\n\nIn order to keep Google Cloud Print destinations discoverable, this policy must be set to true and cloud must not be included in the PrinterTypeDenyList policy.";
CloudPrintWarningsSuppressed.pfm_title = "Suppress Google Cloud Print deprecation messages";
CloudPrintWarningsSuppressed.pfm_description = "This policy controls whether Google Cloud Print deprecation warnings are shown to users in the print preview dialog or settings pages.\nSetting this policy to True will hide the deprecation warnings.\nSetting this policy to False or leaving it unset will show the deprecation warnings.";
CoalesceH2ConnectionsWithClientCertificatesForHosts.pfm_title = "Allow coalescing of HTTP/2 connections for these hosts even when client certificates are used";
CoalesceH2ConnectionsWithClientCertificatesForHosts.pfm_description = "This policy allows HTTP/2 connection coalescing when client certificates are in use. In order to coalesce, both the hostname of the potential new connection and the hostname of an existing connection must match one or more patterns described by this policy. The policy is a list of hosts using the URLBlocklist filter format: \"example.com\" matches \"example.com\" and all subdomains (e.g. \"sub.example.com\"), while \".example.net\" matches exactly \"example.net\".\n\nCoalescing requests to different hosts over connections that use client certificates can create security and privacy issues, as the ambient authority will be conveyed to all requests, even if the user did not explicitly authorize this. This policy is temporary and will be removed in a future release. See https://crbug.com/855690.\n\nIf this policy is left unset, then the default behavior of not allowing any HTTP/2 connection coalescing on connections using client certificates will be used.";
CommandLineFlagSecurityWarningsEnabled.pfm_title = "Enable security warnings for command-line flags";
CommandLineFlagSecurityWarningsEnabled.pfm_description = "Setting the policy to Enabled or leaving it unset means security warnings appear when potentially dangerous command-line flags are used to launch Chrome.\n\nSetting the policy to Disabled prevents security warnings from appearing when Chrome is launched with potentially dangerous command-line flags.\n\nOn Microsoft® Windows®, this functionality is only available on instances that are joined to a Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this functionality is only available on instances that are managed via MDM, or joined to a domain via MCX.";
ComponentUpdatesEnabled.pfm_title = "Enable component updates in Chromium";
ComponentUpdatesEnabled.pfm_description = "Enables component updates for all components in Chromium when not set or set to True.\n\nIf set to False, updates to components are disabled. However, some components are exempt from this policy: updates to any component that does not contain executable code, or does not significantly alter the behavior of the browser, or is critical for its security will not be disabled.\nExamples of such components include the certificate revocation lists and Safe Browsing data.\nSee https://developers.google.com/safe-browsing for more info on Safe Browsing.";
CookiesAllowedForUrls.pfm_title = "Allow cookies on these sites";
CookiesAllowedForUrls.pfm_description = "Allows you to set a list of url patterns that specify sites which are allowed to set cookies.\n\nIf this policy is left not set the global default value will be used for all sites either from the 'DefaultCookiesSetting' policy if it is set, or the user's personal configuration otherwise.\n\nSee also policies 'CookiesBlockedForUrls' and 'CookiesSessionOnlyForUrls'. Note that there must be no conflicting URL patterns between these three policies - it is unspecified which policy takes precedence.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
CookiesBlockedForUrls.pfm_title = "Block cookies on these sites";
CookiesBlockedForUrls.pfm_description = "Setting the policy lets you make a list of URL patterns that specify sites that can't set cookies.\n\nLeaving the policy unset results in the use of DefaultCookiesSetting for all sites, if it's set. If not, the user's personal setting applies.\n\nWhile no specific policy takes precedence, see CookiesBlockedForUrls and CookiesSessionOnlyForUrls. URL patterns among these 3 policies must not conflict.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
CookiesSessionOnlyForUrls.pfm_title = "Limit cookies from matching URLs to the current session";
CookiesSessionOnlyForUrls.pfm_description = "Unless the RestoreOnStartup policy is set to permanently restore URLs from previous sessions, then setting CookiesSessionOnlyForUrls lets you make a list of URL patterns that specify sites that can and can't set cookies for one session.\n\nLeaving the policy unset results in the use of DefaultCookiesSetting for all sites, if it's set. If not, the user's personal setting applies. URLs not covered by the patterns specified also result in the use of defaults.\n\nIf Chromium is running in Background mode, the session might stay active until the user exits the browser, not just closes the last window. See BackgroundModeEnabled for details about configuring this behavior.\n\nWhile no specific policy takes precedence, see CookiesBlockedForUrls and CookiesAllowedForUrls. URL patterns among these 3 policies must not conflict.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
DNSInterceptionChecksEnabled.pfm_title = "DNS interception checks enabled";
DNSInterceptionChecksEnabled.pfm_description = "This policy configures a local switch that can be used to disable DNS interception checks. The checks attempt to discover whether the browser is behind a proxy that redirects unknown host names.\n\nThis detection may not be necessary in an enterprise environment where the network configuration is known, since it causes some amount of DNS and HTTP traffic on start-up and each DNS configuration change.\n\nWhen this policy is not set, or is enabled, the DNS interception checks are performed. When explicitly disabled, they're not.";
DefaultBrowserSettingEnabled.pfm_title = "Set Chromium as Default Browser";
DefaultBrowserSettingEnabled.pfm_description = "Setting the policy to True has Chromium always check whether it's the default browser on startup and, if possible, automatically register itself. Setting the policy to False stops Chromium from ever checking if it's the default and turns user controls off for this option.\n\nLeaving the policy unset means Chromium lets users control whether it's the default and, if not, whether user notifications should appear.\n\nNote: For Microsoft®Windows® administrators, turning this setting on only works for machines running Windows 7. For later versions, you must deploy a \"default application associations\" file that makes Chromium the handler for the https and http protocols (and, optionally, the ftp protocol and other file formats). See Chrome Help ( https://support.google.com/chrome?p=make_chrome_default_win ).";
DefaultCookiesSetting.pfm_title = "Default cookies setting";
DefaultCookiesSetting.pfm_description = "1 - Allow all sites to set local data\n2 - Do not allow any site to set local data\n4 - Keep cookies for the duration of the session\nUnless the RestoreOnStartup policy is set to permanently restore URLs from previous sessions, then setting CookiesSessionOnlyForUrls lets you make a list of URL patterns that specify sites that can and can't set cookies for one session.\n\nLeaving the policy unset results in the use of DefaultCookiesSetting for all sites, if it's set. If not, the user's personal setting applies. URLs not covered by the patterns specified also result in the use of defaults.\n\nIf Chromium is running in Background mode, the session might stay active until the user exits the browser, not just closes the last window. See BackgroundModeEnabled for details about configuring this behavior.\n\nWhile no specific policy takes precedence, see CookiesBlockedForUrls and CookiesAllowedForUrls. URL patterns among these 3 policies must not conflict.";
DefaultDownloadDirectory.pfm_title = "Set default download directory";
DefaultDownloadDirectory.pfm_description = "Setting the policy changes the default directory that Chrome downloads files to, but users can change the directory.\n\nLeaving the policy unset means Chrome uses its platform-specific default directory.\n\nNote: See a list of variables you can use ( https://www.chromium.org/administrators/policy-list-3/user-data-directory-variables ).";
DefaultFileSystemReadGuardSetting.pfm_title = "Control use of the File System API for reading";
DefaultFileSystemReadGuardSetting.pfm_description = "2 - Do not allow any site to request read access to files and directories via the File System API\n3 - Allow sites to ask the user to grant read access to files and directories via the File System API\nSetting the policy to 3 lets websites ask for read access to files and directories in the host operating system's file system via the File System API. Setting the policy to 2 denies access.\n\nLeaving it unset lets websites ask for access, but users can change this setting.";
DefaultFileSystemWriteGuardSetting.pfm_title = "Control use of the File System API for writing";
DefaultFileSystemWriteGuardSetting.pfm_description = "2 - Do not allow any site to request write access to files and directories\n3 - Allow sites to ask the user to grant write access to files and directories\nSetting the policy to 3 lets websites ask for write access to files and directories in the host operating system's file system. Setting the policy to 2 denies access.\n\nLeaving it unset lets websites ask for access, but users can change this setting.";
DefaultGeolocationSetting.pfm_title = "Default geolocation setting";
DefaultGeolocationSetting.pfm_description = "1 - Allow sites to track the users' physical location\n2 - Do not allow any site to track the users' physical location\n3 - Ask whenever a site wants to track the users' physical location\nSetting the policy to 1 lets sites track the users' physical location as the default state. Setting the policy to 2 denies this tracking by default. You can set the policy to ask whenever a site wants to track the users' physical location.\n\nLeaving the policy unset means the AskGeolocation policy applies, but users can change this setting.";
DefaultImagesSetting.pfm_title = "Default images setting";
DefaultImagesSetting.pfm_description = "1 - Allow all sites to show all images\n2 - Do not allow any site to show images\nSetting the policy to 1 lets all websites display images. Setting the policy to 2 denies image display.\n\nLeaving it unset allows images, but users can change this setting.";
DefaultInsecureContentSetting.pfm_title = "Control use of insecure content exceptions";
DefaultInsecureContentSetting.pfm_description = "2 - Do not allow any site to load mixed content\n3 - Allow users to add exceptions to allow mixed content\nAllows you to set whether users can add exceptions to allow mixed content for specific sites.\n\nThis policy can be overridden for specific URL patterns using the 'InsecureContentAllowedForUrls' and 'InsecureContentBlockedForUrls' policies.\n\nIf this policy is left not set, users will be allowed to add exceptions to allow blockable mixed content and disable autoupgrades for optionally blockable mixed content.";
DefaultJavaScriptSetting.pfm_title = "Default JavaScript setting";
DefaultJavaScriptSetting.pfm_description = "1 - Allow all sites to run JavaScript\n2 - Do not allow any site to run JavaScript\nSetting the policy to 1 lets websites run JavaScript. Setting the policy to 2 denies JavaScript.\n\nLeaving it unset allows JavaScript, but users can change this setting.";
DefaultNotificationsSetting.pfm_title = "Default notification setting";
DefaultNotificationsSetting.pfm_description = "1 - Allow sites to show desktop notifications\n2 - Do not allow any site to show desktop notifications\n3 - Ask every time a site wants to show desktop notifications\nSetting the policy to 1 lets websites display desktop notifications. Setting the policy to 2 denies desktop notifications.\n\nLeaving it unset means AskNotifications applies, but users can change this setting.";
DefaultPluginsSetting.pfm_title = "Default Flash setting";
DefaultPluginsSetting.pfm_description = "1 - Allow all sites to automatically run the Flash plugin\n2 - Block the Flash plugin\n3 - Click to play\nSetting the policy to 1 lets you set whether all websites can automatically run the Flash plugin. Setting the policy to 2 denies this plugin for all websites. Click to play lets the Flash plugin run, but users click on the placeholder to start it.\n\nLeaving the policy unset uses BlockPlugins and lets users change this setting.\n\nNote: Automatic playback is only for domains explicitly listed in the PluginsAllowedForUrls policy. To turn automatic playback on for all sites, add http://* and https://* to this list.";
DefaultPopupsSetting.pfm_title = "Default popups setting";
DefaultPopupsSetting.pfm_description = "1 - Allow all sites to show pop-ups\n2 - Do not allow any site to show popups\nSetting the policy to 1 lets websites display pop-ups. Setting the policy to 2 denies pop-ups.\n\nLeaving it unset means BlockPopups applies, but users can change this setting.";
DefaultPrinterSelection.pfm_title = "Default printer selection rules";
DefaultPrinterSelection.pfm_description = "Overrides Chromium default printer selection rules.\n\nThis policy determines the rules for selecting the default printer in Chromium which happens the first time the print function is used with a profile.\n\nWhen this policy is set, Chromium will attempt to find a printer matching all of the specified attributes, and select it as default printer. The first printer found matching the policy is selected, in case of non-unique match any matching printer can be selected, depending on the order printers are discovered.\n\nIf this policy is not set or matching printer is not found within the timeout, the printer defaults to built-in PDF printer or no printer selected, when PDF printer is not available.\n\nPrinters connected to Google Cloud Print are considered \"cloud\", the rest of the printers are classified as \"local\".\nOmitting a field means all values match, for example, not specifying connectivity will cause Print Preview to initiate the discovery of all kinds of printers, local and cloud.\nRegular expression patterns must follow the JavaScript RegExp syntax and matches are case sensistive.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=DefaultPrinterSelection for more information about schema and formatting.";
DefaultSearchProviderAlternateURLs.pfm_title = "List of alternate URLs for the default search provider";
DefaultSearchProviderAlternateURLs.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderAlternateURLs specifies a list of alternate URLs for extracting search terms from the search engine. The URLs should include the string '{searchTerms}'.\n\nLeaving DefaultSearchProviderAlternateURLs unset means no alternate URLs are used to extract search terms.";
DefaultSearchProviderContextMenuAccessAllowed.pfm_title = "Allow default search provider context menu search access";
DefaultSearchProviderContextMenuAccessAllowed.pfm_description = "Enables the use of a default search provider on the context menu.\n\nIf you set this policy to disabled the search context menu item that relies on your default search provider will not be available.\n\nIf this policy is set to enabled or not set, the context menu item for your default search provider will be available.\n\nThe policy value is only appled when the DefaultSearchProviderEnabled policy is enabled, and is not applicable otherwise.";
DefaultSearchProviderEnabled.pfm_title = "Enable the default search provider";
DefaultSearchProviderEnabled.pfm_description = "Setting the policy to Enabled means a default search is performed when a user enters non-URL text in the address bar. To specify the default search provider, set the rest of the default search policies. If you leave those policies empty, the user can choose the default provider. Setting the policy to Disabled means there's no search when the user enters non-URL text in the address bar.\n\nIf you set the policy, users can't change it in Chromium. If not set, the default search provider is on, and users can set the search provider list.\n\nOn Microsoft® Windows®, this functionality is only available on instances that are joined to a Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this functionality is only available on instances that are managed via MDM, or joined to a domain via MCX.";
DefaultSearchProviderEncodings.pfm_title = "Default search provider encodings";
DefaultSearchProviderEncodings.pfm_description = "If DefaultSearchProviderEnabled is on, setting DefaultSearchProviderEncodings specifies the character encodings supported by the search provider. Encodings are code page names such as UTF-8, GB2312, and ISO-8859-1. They're tried in the order provided.\n\nLeaving DefaultSearchProviderEncodings unset puts UTF-8 in use.";
DefaultSearchProviderIconURL.pfm_title = "Default search provider icon";
DefaultSearchProviderIconURL.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderIconURL specifies the default search provider's favorite icon URL.\n\nLeaving DefaultSearchProviderIconURL unset means there's no icon for the search provider.";
DefaultSearchProviderImageURL.pfm_title = "Parameter providing search-by-image feature for the default search provider";
DefaultSearchProviderImageURL.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderImageURL specifies the URL of the search engine used for image search. (If DefaultSearchProviderImageURLPostParams is set, then image search requests use the POST method instead.)\n\nLeaving DefaultSearchProviderImageURL unset means no image search is used.";
DefaultSearchProviderImageURLPostParams.pfm_title = "Parameters for image URL which uses POST";
DefaultSearchProviderImageURLPostParams.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderImageURLPostParams specifies the parameters during image search with POST. It consists of comma-separated, name-value pairs. If a value is a template parameter, such as {imageThumbnail}, real image thumbnail data replaces it.\n\nLeaving DefaultSearchProviderImageURLPostParams unset means image search request is sent using the GET method.";
DefaultSearchProviderKeyword.pfm_title = "Default search provider keyword";
DefaultSearchProviderKeyword.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderKeyword specifies the keyword or shortcut used in the address bar to trigger the search for this provider.\n\nLeaving DefaultSearchProviderKeyword unset means no keyword activates the search provider.";
DefaultSearchProviderName.pfm_title = "Default search provider name";
DefaultSearchProviderName.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderName specifies the default search provider's name.\n\nLeaving DefaultSearchProviderName unset means the hostname specified by the search URL is used.";
DefaultSearchProviderNewTabURL.pfm_title = "Default search provider new tab page URL";
DefaultSearchProviderNewTabURL.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderNewTabURL specifies the URL of the search engine used to provide a New Tab page.\n\nLeaving DefaultSearchProviderNewTabURL unset means no new tab page is provided.";
DefaultSearchProviderSearchURL.pfm_title = "Default search provider search URL";
DefaultSearchProviderSearchURL.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderSearchURL specifies the URL of the search engine used during a default search. The URL should include the string '{searchTerms}', replaced in the query by the user's search terms.\n\nYou can specify Google's search URL as: '{google:baseURL}search?q={searchTerms}&{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQueryStats}{google:searchFieldtrialParameter}{google:searchClient}{google:sourceId}ie={inputEncoding}'.";
DefaultSearchProviderSearchURLPostParams.pfm_title = "Parameters for search URL which uses POST";
DefaultSearchProviderSearchURLPostParams.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderSearchURLPostParams specifies the parameters when searching a URL with POST. It consists of comma-separated, name-value pairs. If a value is a template parameter, such as '{searchTerms}', real search terms data replaces it.\n\nLeaving DefaultSearchProviderSearchURLPostParams unset means search requests are sent using the GET method.";
DefaultSearchProviderSuggestURL.pfm_title = "Default search provider suggest URL";
DefaultSearchProviderSuggestURL.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderSuggestURL specifies the URL of the search engine to provide search suggestions. The URL should include the string '{searchTerms}', replaced in the query by the user's search terms.\n\nYou can specify Google's search URL as: '{google:baseURL}complete/search?output=chrome&q={searchTerms}'.";
DefaultSearchProviderSuggestURLPostParams.pfm_title = "Parameters for suggest URL which uses POST";
DefaultSearchProviderSuggestURLPostParams.pfm_description = "If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderSuggestURLPostParams specifies the parameters during suggestion search with POST. It consists of comma-separated, name-value pairs. If a value is a template parameter, such as '{searchTerms}', real search terms data replaces it.\n\nLeaving DefaultSearchProviderSuggestURLPostParams unset unset means suggest search requests are sent using the GET method.";
DefaultSerialGuardSetting.pfm_title = "Control use of the Serial API";
DefaultSerialGuardSetting.pfm_description = "2 - Do not allow any site to request access to serial ports via the Serial API\n3 - Allow sites to ask the user to grant access to a serial port\nSetting the policy to 3 lets websites ask for access to serial ports. Setting the policy to 2 denies access to serial ports.\n\nLeaving it unset lets websites ask for access, but users can change this setting.";
DefaultWebBluetoothGuardSetting.pfm_title = "Control use of the Web Bluetooth API";
DefaultWebBluetoothGuardSetting.pfm_description = "2 - Do not allow any site to request access to Bluetooth devices via the Web Bluetooth API\n3 - Allow sites to ask the user to grant access to a nearby Bluetooth device\nSetting the policy to 3 lets websites ask for access to nearby Bluetooth devices. Setting the policy to 2 denies access to nearby Bluetooth devices.\n\nLeaving the policy unset lets sites ask for access, but users can change this setting.";
DefaultWebUsbGuardSetting.pfm_title = "Control use of the WebUSB API";
DefaultWebUsbGuardSetting.pfm_description = "2 - Do not allow any site to request access to USB devices via the WebUSB API\n3 - Allow sites to ask the user to grant access to a connected USB device\nSetting the policy to 3 lets websites ask for access to connected USB devices. Setting the policy to 2 denies access to connected USB devices.\n\nLeaving it unset lets websites ask for access, but users can change this setting.";
DeveloperToolsAvailability.pfm_title = "Control where Developer Tools can be used";
DeveloperToolsAvailability.pfm_description = "0 - Disallow usage of the Developer Tools on extensions installed by enterprise policy, allow usage of the Developer Tools in other contexts\n1 - Allow usage of the Developer Tools\n2 - Disallow usage of the Developer Tools\nSetting the policy to 0 (the default) means you can access the developer tools and the JavaScript console, but not in the context of extensions installed by enterprise policy. Setting the policy to 1 means you can access the developer tools and the JavaScript console in all contexts, including that of extensions installed by enterprise policy. Setting the policy to 2 means you can't acess developer tools, and you can't inspect website elements.\n\nThis setting also turns off keyboard shortcuts and menu or context menu entries to open developer tools or the JavaScript console.";
Disable3DAPIs.pfm_title = "Disable support for 3D graphics APIs";
Disable3DAPIs.pfm_description = "Setting the policy to True (or setting HardwareAccelerationModeEnabled to False) prevents webpages from accessing the WebGL API, and plugins can't use the Pepper 3D API.\n\nSetting the policy to False or leaving it unset lets webpages use the WebGL API and plugins use the Pepper 3D API, but the browser's default settings might still require command line arguments to use these APIs.";
DisableAuthNegotiateCnameLookup.pfm_title = "Disable CNAME lookup when negotiating Kerberos authentication";
DisableAuthNegotiateCnameLookup.pfm_description = "Setting the policy to Enabled skips CNAME lookup. The server name is used as entered when generating the Kerberos SPN.\n\nSetting the policy to Disabled or leaving it unset means CNAME lookup determines the canonical name of the server when generating the Kerberos SPN.";
DisablePrintPreview.pfm_title = "Disable Print Preview";
DisablePrintPreview.pfm_description = "Show the system print dialog instead of print preview.\n\nWhen this setting is enabled, Chromium will open the system print dialog instead of the built-in print preview when a user requests a page to be printed.\n\nIf this policy is not set or is set to false, print commands trigger the print preview screen.";
DisableSafeBrowsingProceedAnyway.pfm_title = "Disable proceeding from the Safe Browsing warning page";
DisableSafeBrowsingProceedAnyway.pfm_description = "Setting the policy to Enabled prevents users from proceeding past the warning page the Safe Browsing service shows to the malicious site. This policy only prevents users from proceeding on Safe Browsing warnings such as malware and phishing, not for SSL certificate-related issues such as invalid or expired certificates.\n\nSetting the policy to Disabled or leaving it unset means users can choose to proceed to the flagged site after the warning appears.\n\nSee more about Safe Browsing ( https://developers.google.com/safe-browsing ).";
DisableScreenshots.pfm_title = "Disable taking screenshots";
DisableScreenshots.pfm_description = "Setting the policy to True disallows screenshots taken with keyboard shortcuts or extension APIs. Setting the policy to False allows screenshots.";
DiskCacheDir.pfm_title = "Set disk cache directory";
DiskCacheDir.pfm_description = "Setting the policy has Chromium use the directory you provide for storing cached files on the disk—whether or not users specify the --disk-cache-dir flag.\n\nIf not set, Chromium uses the default cache directory, but users can change that setting with the --disk-cache-dir command line flag.\n\nChromium manages the contents of a volume's root directory. So to avoid data loss or other errors, do not set this policy to the root directory or any directory used for other purposes. See the variables you can use ( https://www.chromium.org/administrators/policy-list-3/user-data-directory-variables ).";
DiskCacheSize.pfm_title = "Set disk cache size";
DiskCacheSize.pfm_description = "Setting the policy to None has Chromium use the default cache size for storing cached files on the disk. Users can't change it.\n\nIf you set the policy, Chromium uses the cache size you provide—whether or not users specify the --disk-cache-size flag. (Values below a few megabytes are rounded up.)\n\nIf not set, Chromium uses the default size. Users can change that setting using the --disk-cache-size flag.";
DnsOverHttpsMode.pfm_title = "Controls the mode of DNS-over-HTTPS";
DnsOverHttpsMode.pfm_description = "off - Disable DNS-over-HTTPS\nautomatic - Enable DNS-over-HTTPS with insecure fallback\nsecure - Enable DNS-over-HTTPS without insecure fallback\nControls the mode of the DNS-over-HTTPS resolver. Please note that this policy will only set the default mode for each query. The mode may be overridden for special types of queries such as requests to resolve a DNS-over-HTTPS server hostname.\n\nThe \"off\" mode will disable DNS-over-HTTPS.\n\nThe \"automatic\" mode will send DNS-over-HTTPS queries first if a DNS-over-HTTPS server is available and may fallback to sending insecure queries on error.\n\nThe \"secure\" mode will only send DNS-over-HTTPS queries and will fail to resolve on error.\n\nOn Android Pie and above, if DNS-over-TLS is active, Chromium will not send insecure DNS requests.\n\nIf this policy is unset the browser may send DNS-over-HTTPS requests to a resolver associated with the user's configured system resolver.";
DnsOverHttpsTemplates.pfm_title = "Specify URI template of desired DNS-over-HTTPS resolver";
DnsOverHttpsTemplates.pfm_description = "The URI template of the desired DNS-over-HTTPS resolver. To specify multiple DNS-over-HTTPS resolvers, separate the corresponding URI templates with spaces.\n\nIf the DnsOverHttpsMode is set to \"secure\" then this policy must be set and not empty.\n\nIf the DnsOverHttpsMode is set to \"automatic\" and this policy is set then the URI templates specified will be used; if this policy is unset then hardcoded mappings will be used to attempt to upgrade the user's current DNS resolver to a DoH resolver operated by the same provider.\n\nIf the URI template contains a dns variable, requests to the resolver will use GET; otherwise requests will use POST.\n\nIncorrectly formatted templates will be ignored.";
DownloadDirectory.pfm_title = "Set download directory";
DownloadDirectory.pfm_description = "Setting the policy sets up the directory Chrome uses for downloading files. It uses the provided directory, whether or not users specify one or turned on the flag to be prompted for download location every time.\n\nLeaving the policy unset means Chrome uses the default download directory, and users can change it.\n\nNote: See a list of variables you can use ( https://www.chromium.org/administrators/policy-list-3/user-data-directory-variables ).";
DownloadRestrictions.pfm_title = "Download restrictions";
DownloadRestrictions.pfm_description = "0 - No special restrictions\n1 - Block dangerous downloads\n2 - Block potentially dangerous downloads\n3 - Block all downloads\n4 - Block malicious downloads\nSetting the policy means users can't bypass download security decisions.\n\n Setting the policy to:\n\n* Block dangerous downloads means all downloads are allowed, except for those that carry Safe Browsing warnings.\n\n* Block potentially dangerous downloads means all downloads allowed, except for those that carry Safe Browsing warnings of potentially dangerous downloads.\n\n* Block all downloads means all downloads are blocked.\n\n* Block malicious downloads means all downloads are allowed, except for those that Safe Browsing assesses to be malware with high confidence. Unlike with dangerous downloads, this does not take into account file type, but does take into account the host.\n\n* No special restrictions means the downloads go through the usual security restrictions based on Safe Browsing analysis results.\n\nNote: These restrictions apply to downloads triggered from webpage content, as well as the Download link... menu option. They don't apply to the download of the currently displayed page or to saving as PDF from the printing options. Read more about Safe Browsing ( https://developers.google.com/safe-browsing ).";
EditBookmarksEnabled.pfm_title = "Enable or disable bookmark editing";
EditBookmarksEnabled.pfm_description = "Setting the policy to True or leaving it unset lets users add, remove, or modify bookmarks.\n\nSetting the policy to False means users can't add, remove, or modify bookmarks. They can still use existing bookmarks.";
EnableAuthNegotiatePort.pfm_title = "Include non-standard port in Kerberos SPN";
EnableAuthNegotiatePort.pfm_description = "Setting the policy to Enabled and entering a nonstandard port (in other words, a port other than 80 or 443) includes it in the generated Kerberos SPN.\n\nSetting the policy to Disabled or leaving it unset means the generated Kerberos SPN won't include a port.";
EnableDeprecatedWebPlatformFeatures.pfm_title = "Enable deprecated web platform features for a limited time";
EnableDeprecatedWebPlatformFeatures.pfm_description = "ExampleDeprecatedFeature_EffectiveUntil20080902 - Enable ExampleDeprecatedFeature API through 2008/09/02\nSpecify a list of deprecated web platform features to re-enable temporarily.\n\nThis policy gives administrators the ability to re-enable deprecated web platform features for a limited time. Features are identified by a string tag and the features corresponding to the tags included in the list specified by this policy will get re-enabled.\n\nIf this policy is left not set, or the list is empty or does not match one of the supported string tags, all deprecated web platform features will remain disabled.\n\nWhile the policy itself is supported on the above platforms, the feature it is enabling may be available on fewer platforms. Not all deprecated Web Platform features can be re-enabled. Only the ones explicitly listed below can be for a limited period of time, which is different per feature. The general format of the string tag will be [DeprecatedFeatureName]_EffectiveUntil[yyyymmdd]. As reference, you can find the intent behind the Web Platform feature changes at https://bit.ly/blinkintents.\n";
EnableExperimentalPolicies.pfm_title = "Enables experimental policies";
EnableExperimentalPolicies.pfm_description = "Allows Chromium to load experimental policies.\n\nWARNING: Experimental policies are unsupported and subject to change or be removed without notice in future version of the browser!\n\nAn experimental policy may not be finished or still have known or unknown defects. It may be changed or even removed without any notification. By enabling experimental policies, you could lose browser data or compromise your security or privacy.\n\nIf a policy is not in the list and it's not officially released, its value will be ignored on Beta and Stable channel.\n\nIf a policy is in the list and it's not officially released, its value will be applied.\n\nThis policy has no effect on already released policies.";
EnableMediaRouter.pfm_title = "Enable Google Cast";
EnableMediaRouter.pfm_description = "Setting the policy to Enabled or leaving it unset turns on Google Cast, which users can launch from the app menu, page context menus, media controls on Cast-enabled websites, and (if shown) the Cast toolbar icon.\n\nSetting the policy to Disabled turns off Google Cast.";
EnableOnlineRevocationChecks.pfm_title = "Enable online OCSP/CRL checks";
EnableOnlineRevocationChecks.pfm_description = "Setting the policy to True means online OCSP/CRL checks are performed.\n\nSetting the policy to False or leaving it unset means Chromium won't perform online revocation checks in Chromium 19 and later.\n\nNote: OCSP/CRL checks provide no effective security benefit.";
EnterpriseHardwarePlatformAPIEnabled.pfm_title = "Enables managed extensions to use the Enterprise Hardware Platform API";
EnterpriseHardwarePlatformAPIEnabled.pfm_description = "Setting the policy to True lets extensions installed by enterprise policy use the Enterprise Hardware Platform API.\n\nSetting the policy to False or leaving it unset prevents extensions from using this API.\n\nNote: This policy also applies to component extensions, such as the Hangout Services extension.";
EnterpriseRealTimeUrlCheckMode.pfm_title = "Check Safe Browsing status of URLs in real time";
EnterpriseRealTimeUrlCheckMode.pfm_description = "0 - Real time URL check is disabled.\n1 - Real time check for main frame URLs is enabled.\nThis policy controls checking URLs in real time to identify unsafe URLs.\n\nIf this policy is left not set or set to ‘Disabled’, the consumer Safe Browsing checks will be applied. Consumer Safe Browsing checks can still include real time lookups, depending on the value of the “Make searches and browsing better” setting and the value of the UrlKeyedAnonymizedDataCollectionEnabled policy.\n\nIf this policy is set to ‘Enabled’, URLs will be sent to be scanned in real time under enterprise ToS. It will result in Chrome sending URLs to Google Cloud or third parties of your choosing to check them in real time. The consumer version of Safe Browsing real time lookup will be switched off.\n\nThis policy can only be set from the Google Admin console.";
ExtensionAllowedTypes.pfm_title = "Types of extensions/apps that are allowed to be installed";
ExtensionAllowedTypes.pfm_description = "Setting the policy controls which apps and extensions may be installed in Chromium, which hosts they can interact with, and limits runtime access.\n\nLeaving the policy unset results in no restrictions on the acceptable extension and app types.\n\nExtensions and apps which have a type that's not on the list won't be installed. Each value should be one of these strings:\n\n* \"extension\"\n\n* \"theme\"\n\n* \"user_script\"\n\n* \"hosted_app\"\n\n* \"legacy_packaged_app\"\n\n* \"platform_app\"\n\nSee the Chromium extensions documentation for more information on these types.\n\nVersions earlier than 75 that use multiple comma separated extension IDs aren't supported and are skipped. The rest of the policy applies.\n\nNote: This policy also affects extensions and apps to be force-installed using ExtensionInstallForcelist.";
ExtensionInstallAllowlist.pfm_title = "Extension IDs to exempt from the blocklist";
ExtensionInstallAllowlist.pfm_description = "Setting the policy specifies which extensions are not subject to the blocklist.\n\nA blocklist value of * means all extensions are blocked and users can only install extensions listed in the allow list.\n\nBy default, all extensions are allowed. But, if you prohibited extensions by policy, use the list of allowed extensions to change that policy.";
ExtensionInstallBlocklist.pfm_title = "Extension IDs the user should be prevented from installing (or * for all)";
ExtensionInstallBlocklist.pfm_description = "Allows you to specify which extensions the users can NOT install. Extensions already installed will be disabled if blocked, without a way for the user to enable them. Once an extension disabled due to the blocklist is removed from it, it will automatically get re-enabled.\n\nA blocklist value of '*' means all extensions are blocked unless they are explicitly listed in the allowlist.\n\nIf this policy is left not set the user can install any extension in Chromium.";
ExtensionInstallForcelist.pfm_title = "Extension/App IDs and update URLs to be silently installed";
ExtensionInstallForcelist.pfm_description = "Setting the policy specifies a list of apps and extensions that install silently, without user interaction, and which users can't uninstall or turn off. Permissions are granted implicitly, including for the enterprise.deviceAttributes and enterprise.platformKeys extension APIs. (These 2 APIs aren't available to apps and extensions that aren't force-installed.)\n\nLeaving the policy unset means no apps or extensions are autoinstalled, and users can uninstall any app or extension in Chromium.\n\nThis policy superseeds ExtensionInstallBlocklist policy. If a previously force-installed app or extension is removed from this list, Chromium automatically uninstalls it.\n\nOn Microsoft® Windows® instances, apps and extensions from outside the Chrome Web Store can only be forced installed if the instance is joined to a Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled in Chrome Browser Cloud Management.\n\nOn macOS instances, apps and extensions from outside the Chrome Web Store can only be force installed if the instance is managed via MDM, or joined to a domain via MCX.\n\nThe source code of any extension may be altered by users through developer tools, potentially rendering the extension dysfunctional. If this is a concern, set the DeveloperToolsDisabled policy.\n\nEach list item of the policy is a string that contains an extension ID and, optionally, an \"update\" URL separated by a semicolon (;). The extension ID is the 32-letter string found, for example, on chrome://extensions when in Developer mode. If specified, the \"update\" URL should point to an Update Manifest XML document ( https://developer.chrome.com/extensions/autoupdate ). By default, the Chrome Web Store's update URL is used. The \"update\" URL set in this policy is only used for the initial installation; subsequent updates of the extension use the update URL in the extension's manifest.\n\n Note: This policy doesn't apply to Incognito mode. Read about hosting extensions ( https://developer.chrome.com/extensions/hosting ).";
ExtensionInstallSources.pfm_title = "URL patterns to allow extension, app, and user script installs from";
ExtensionInstallSources.pfm_description = "Setting the policy specifies which URLs may install extensions, apps, and themes. Before Chromium 21, users could click on a link to a *.crx file, and Chromium would offer to install the file after a few warnings. Afterwards, such files must be downloaded and dragged to the Chromium settings page. This setting allows specific URLs to have the old, easier installation flow.\n\nEach item in this list is an extension-style match pattern (see https://developer.chrome.com/extensions/match_patterns). Users can easily install items from any URL that matches an item in this list. Both the location of the *.crx file and the page where the download is started from (the referrer) must be allowed by these patterns.\n\nExtensionInstallBlocklist takes precedence over this policy. That is, an extension on the blocklist won't be installed, even if it happens from a site on this list.";
ExtensionSettings.pfm_title = "Extension management settings";
ExtensionSettings.pfm_description = "Setting the policy controls extension management settings for Chromium, including any controlled by existing extension-related policies. The policy supersedes any legacy policies that might be set.\n\nThis policy maps an extension ID or an update URL to its specific setting only. A default configuration can be set for the special ID \"*\", which applies to all extensions without a custom configuration in this policy. With an update URL, configuration applies to extensions with the exact update URL stated in the extension manifest ( http://support.google.com/chrome/a?p=Configure_ExtensionSettings_policy ).\n\nNote: For Windows® instances not joined to a Microsoft® Active Directory® domain, forced installation is limited to apps and extensions listed in the Chrome Web Store.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=ExtensionSettings for more information about schema and formatting.";
ExternalProtocolDialogShowAlwaysOpenCheckbox.pfm_title = "Show an \"Always open\" checkbox in external protocol dialog.";
ExternalProtocolDialogShowAlwaysOpenCheckbox.pfm_description = "This policy controls whether or not the \"Always open\" checkbox is shown on external protocol launch confirmation prompts.\n\n     If this policy is set to True or not set, when an external protocol confirmation is shown, the user can select \"Always allow\" to skip all future confirmation prompts for the protocol on this site.\n\n     If this policy is set to False, the \"Always allow\" checkbox is not displayed and the user will be prompted each time an external protocol is invoked.";
FileSystemReadAskForUrls.pfm_title = "Allow read access via the File System API on these sites";
FileSystemReadAskForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can ask users to grant them read access to files or directories in the host operating system's file system via the File System API.\n\nLeaving the policy unset means DefaultFileSystemReadGuardSetting applies for all sites, if it's set. If not, users' personal settings apply.\n\nURL patterns must not conflict with FileSystemReadBlockedForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
FileSystemReadBlockedForUrls.pfm_title = "Block read access via the File System API on these sites";
FileSystemReadBlockedForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can't ask users to grant them read access to files or directories in the host operating system's file system via the File System API.\n\nLeaving the policy unset means DefaultFileSystemReadGuardSetting applies for all sites, if it's set. If not, users' personal settings apply.\n\nURL patterns can't conflict with FileSystemReadAskForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
FileSystemWriteAskForUrls.pfm_title = "Allow write access to files and directories on these sites";
FileSystemWriteAskForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can ask users to grant them write access to files or directories in the host operating system's file system.\n\nLeaving the policy unset means DefaultFileSystemWriteGuardSetting applies for all sites, if it's set. If not, users' personal settings apply.\n\nURL patterns must not conflict with FileSystemWriteBlockedForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
FileSystemWriteBlockedForUrls.pfm_title = "Block write access to files and directories on these sites";
FileSystemWriteBlockedForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can't ask users to grant them write access to files or directories in the host operating system's file system.\n\nLeaving the policy unset means DefaultFileSystemWriteGuardSetting applies for all sites, if it's set. If not, users' personal settings apply.\n\nURL patterns can't conflict with FileSystemWriteAskForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
ForceEphemeralProfiles.pfm_title = "Ephemeral profile";
ForceEphemeralProfiles.pfm_description = "If set to enabled this policy forces the profile to be switched to ephemeral mode. If this policy is specified as an OS policy (e.g. GPO on Windows) it will apply to every profile on the system; if the policy is set as a Cloud policy it will apply only to a profile signed in with a managed account.\n\nIn this mode the profile data is persisted on disk only for the length of the user session. Features like browser history, extensions and their data, web data like cookies and web databases are not preserved after the browser is closed. However this does not prevent the user from downloading any data to disk manually, save pages or print them.\n\nIf the user has enabled sync all this data is preserved in their sync profile just like with regular profiles. Incognito mode is also available if not explicitly disabled by policy.\n\nIf the policy is set to disabled or left not set signing in leads to regular profiles.";
ForceGoogleSafeSearch.pfm_title = "Force Google SafeSearch";
ForceGoogleSafeSearch.pfm_description = "Setting the policy to Enabled means SafeSearch in Google Search is always active, and users can't change this setting.\n\nSetting the policy to Disabled or leaving it unset means SafeSearch in Google Search is not enforced.";
ForceLegacyDefaultReferrerPolicy.pfm_title = "Use a default referrer policy of no-referrer-when-downgrade.";
ForceLegacyDefaultReferrerPolicy.pfm_description = "This enterprise policy is for short-term adaptation and will be removed in Chromium version 88.\n\nChrome's default referrer policy is being strengthened from its current value of no-referrer-when-downgrade to the more secure strict-origin-when-cross-origin through a gradual rollout targeting Chrome 85 stable.\n\nBefore the rollout, this enterprise policy will have no effect. After the rollout, when this enterprise policy is enabled, Chrome's default referrer policy will be set to its previous value of no-referrer-when-downgrade.\n\nThis enterprise policy is disabled by default.";
ForceYouTubeRestrict.pfm_title = "Force minimum YouTube Restricted Mode";
ForceYouTubeRestrict.pfm_description = "0 - Do not enforce Restricted Mode on YouTube\n1 - Enforce at least Moderate Restricted Mode on YouTube\n2 - Enforce Strict Restricted Mode for YouTube\nSetting the policy enforces a minimum Restricted mode on YouTube and prevents users from picking a less restricted mode. If you set it to:\n\n* Strict, Strict Restricted mode on YouTube is always active.\n\n* Moderate, the user may only pick Moderate Restricted mode and Strict Restricted mode on YouTube, but can't turn off Restricted mode.\n\n* Off or if no value is set, Restricted mode on YouTube isn't enforced by Chrome. External policies such as YouTube policies might still enforce Restricted mode.";
GloballyScopeHTTPAuthCacheEnabled.pfm_title = "Enable globally scoped HTTP auth cache";
GloballyScopeHTTPAuthCacheEnabled.pfm_description = "This policy configures a single global per profile cache with HTTP server authentication credentials.\n\nIf this policy is unset or disabled, the browser will use the default behavior of cross-site auth, which as of version 80, will be to scope HTTP server authentication credentials by top-level site, so if two sites use resources from the same authenticating domain, credentials will need to be provided independently in the context of both sites. Cached proxy credentials will be reused across sites.\n\nIf the policy is enabled, HTTP auth credentials entered in the context of one site will automatically be used in the context of another.\n\nEnabling this policy leaves sites open to some types of cross-site attacks, and allows users to be tracked across sites even without cookies by adding entries to the HTTP auth cache using credentials embedded in URLs.\n\nThis policy is intended to give enterprises depending on the legacy behavior a chance to update their login procedures, and will be removed in the future.";
HSTSPolicyBypassList.pfm_title = "List of names that will bypass the HSTS policy check";
HSTSPolicyBypassList.pfm_description = "Hostnames specified in this list will be exempt from the HSTS policy check that could potentially upgrade requests from http to https. Only single-label hostnames are allowed in this policy. Hostnames must be canonicalized: any IDNs must be converted to their A-label format, and all ASCII letters must be lowercase. This policy only applies to the specific hostnames specified; it does not apply to subdomains of the names specified.";
HardwareAccelerationModeEnabled.pfm_title = "Use hardware acceleration when available";
HardwareAccelerationModeEnabled.pfm_description = "If this policy is set to true or left unset, hardware acceleration will be enabled unless a certain GPU feature is blacklisted.\n\nIf this policy is set to false, hardware acceleration will be disabled.";
HideWebStoreIcon.pfm_title = "Hide the web store from the New Tab Page and app launcher";
HideWebStoreIcon.pfm_description = "Hide the Chrome Web Store app and footer link from the New Tab Page and Chromium OS app launcher.\n\nWhen this policy is set to true, the icons are hidden.\n\nWhen this policy is set to false or is not configured, the icons are visible.";
HomepageIsNewTabPage.pfm_title = "Use New Tab Page as homepage";
HomepageIsNewTabPage.pfm_description = "Configures the type of the default home page in Chromium and prevents users from changing home page preferences. The home page can either be set to a URL you specify or set to the New Tab Page.\n\nIf you enable this setting, the New Tab Page is always used for the home page, and the home page URL location is ignored.\n\nIf you disable this setting, the user's homepage will never be the New Tab Page, unless its URL is set to 'chrome://newtab'.\n\nIf you enable or disable this setting, users cannot change their homepage type in Chromium.\n\nLeaving this policy not set will allow the user to choose whether the new tab page is their home page on their own.\n\nThis policy is available only on Windows instances that are joined to a Microsoft® Active Directory® domain. or Windows 10 Pro or Enterprise instances that enrolled for device management and macOS instances that are that are managed via MDM or joined to a domain via MCX.";
HomepageLocation.pfm_title = "Home page URL";
HomepageLocation.pfm_description = "Configures the default home page URL in Chromium and prevents users from changing it.\n\nThe home page is the page opened by the Home button. On desktop, the pages that open on startup are controlled by the RestoreOnStartup policies.\n\nThe home page type can either be set to a URL you specify here or set to the New Tab Page. If you select the New Tab Page, then this policy does not take effect.\n\nIf you enable this setting, users cannot change their home page URL in Chromium, but they can still choose the New Tab Page as their home page.\n\nLeaving this policy not set will allow the user to choose their home page on their own if HomepageIsNewTabPage is not set too.\n\nThe URL must have a standard scheme, e.g. \"http://example.com\" or \"https://example.com\".\n\nThis policy is available only on Windows instances that are joined to a Microsoft® Active Directory® domain. or Windows 10 Pro or Enterprise instances that enrolled for device management and macOS instances that are that are managed via MDM or joined to a domain via MCX.";
ImagesAllowedForUrls.pfm_title = "Allow images on these sites";
ImagesAllowedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify sites that may display images.\n\nLeaving the policy unset means DefaultImagesSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.\n\nNote that previously this policy was erroneously enabled on Android, but this functionality has never been fully supported on Android.";
ImagesBlockedForUrls.pfm_title = "Block images on these sites";
ImagesBlockedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify sites that can't display images.\n\nLeaving the policy unset means DefaultImagesSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\n For detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.\n\n Note that previously this policy was erroneously enabled on Android, but this functionality has never been fully supported on Android.";
ImportAutofillFormData.pfm_title = "Import autofill form data from default browser on first run";
ImportAutofillFormData.pfm_description = "Setting the policy to Enabled imports autofill form data from the previous default browser on first run. Setting the policy to Disabled or leaving it unset means no autofill form data is imported on first run.\n\nUsers can trigger an import dialog and the autofill form data checkbox will be checked or unchecked to match this policy's value.";
ImportBookmarks.pfm_title = "Import bookmarks from default browser on first run";
ImportBookmarks.pfm_description = "Setting the policy to Enabled imports bookmarks from the previous default browser on first run. Setting the policy to Disabled or leaving it unset means no bookmarks are imported on first run.\n\nUsers can trigger an import dialog and the bookmarks checkbox will be checked or unchecked to match this policy's value.";
ImportHistory.pfm_title = "Import browsing history from default browser on first run";
ImportHistory.pfm_description = "Setting the policy to Enabled imports browsing history from the previous default browser on first run. Setting the policy to Disabled or leaving it unset means no browsing history is imported on first run.\n\nUsers can trigger an import dialog and the browsing history checkbox will be checked or unchecked to match this policy's value.";
ImportHomepage.pfm_title = "Import of homepage from default browser on first run";
ImportHomepage.pfm_description = "Setting the policy to Enabled imports the homepage from the previous default browser on first run. Setting the policy to Disabled or leaving it unset means the homepage isn't imported on first run.\n\nUsers can trigger an import dialog and the homepage checkbox will be checked or unchecked to match this policy's value.";
ImportSavedPasswords.pfm_title = "Import saved passwords from default browser on first run";
ImportSavedPasswords.pfm_description = "Setting the policy to Enabled imports saved passwords from the previous default browser on first run. Setting the policy to Disabled or leaving it unset means no saved passwords are imported on first run.\n\nUsers can trigger an import dialog and the saved passwords checkbox will be checked or unchecked to match this policy's value.";
ImportSearchEngine.pfm_title = "Import search engines from default browser on first run";
ImportSearchEngine.pfm_description = "Setting the policy to Enabled imports the default search engine from the previous default browser on first run. Setting the policy to Disabled or leaving it unset means the default search engine isn't imported on first run.\n\nUsers can trigger an import dialog and the default search engine checkbox will be checked or unchecked to match this policy's value.";
IncognitoModeAvailability.pfm_title = "Incognito mode availability";
IncognitoModeAvailability.pfm_description = "0 - Incognito mode available\n1 - Incognito mode disabled\n2 - Incognito mode forced\nSpecifies whether the user may open pages in Incognito mode in Chromium.\n\nIf 'Enabled' is selected or the policy is left unset, pages may be opened in Incognito mode.\n\nIf 'Disabled' is selected, pages may not be opened in Incognito mode.\n\nIf 'Forced' is selected, pages may be opened ONLY in Incognito mode. Note that 'Forced' does not work for Android-on-Chrome";
InsecureContentAllowedForUrls.pfm_title = "Allow insecure content on these sites";
InsecureContentAllowedForUrls.pfm_description = "Allows you to set a list of url patterns that specify sites which are allowed to display blockable (i.e. active) mixed content (i.e. HTTP content on HTTPS sites) and for which optionally blockable mixed content upgrades will be disabled.\n\nIf this policy is left not set blockable mixed content will be blocked and optionally blockable mixed content will be upgraded, and users will be allowed to set exceptions to allow it for specific sites.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
InsecureContentBlockedForUrls.pfm_title = "Block insecure content on these sites";
InsecureContentBlockedForUrls.pfm_description = "Allows you to set a list of url patterns that specify sites which are not allowed to display blockable (i.e. active) mixed content (i.e. HTTP content on HTTPS sites), and for which optionally blockable (i.e. passive) mixed content will be upgraded.\n\nIf this policy is left not set blockable mixed content will be blocked and optionally blockable mixed content will be upgraded, but users will be allowed to set exceptions to allow it for specific sites.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
InsecureFormsWarningsEnabled.pfm_title = "Enable warnings for insecure forms";
InsecureFormsWarningsEnabled.pfm_description = "This policy controls the treatment for insecure forms (forms that submit over HTTP) embedded in secure (HTTPS) sites in the browser.\nIf the policy is enabled or unset, a full page warning will be shown when an insecure form is submitted. Additionally, a warning bubble will be shown next to the form fields when they are focused, and autofill will be disabled for those forms.\nIf the policy is disabled, warnings will not be shown for insecure forms, and autofill will work normally.";
IntensiveWakeUpThrottlingEnabled.pfm_title = "Control the IntensiveWakeUpThrottling feature.";
IntensiveWakeUpThrottlingEnabled.pfm_description = "When enabled the IntensiveWakeUpThrottling feature causes Javascript timers in background tabs to be aggressively throttled and coalesced, running no more than once per minute after a page has been backgrounded for 5 minutes or more.\n\nThis is a web standards compliant feature, but it may break functionality\non some websites by causing certain actions to be delayed by up to a\nminute. However, it results in significant CPU and battery savings when\nenabled. See https://bit.ly/30b1XR4 for more details.\n\nIf this policy is set to enabled then the feature will be force enabled, and\nusers will not be able to override this.\n\nIf this policy is set to disabled then the feature will be force disabled, and\nusers will not be able to override this.\n\nIf this policy is left unset then the feature will be controlled by its\nown internal logic, which can be manually configured by users.\n\nNote that the policy is applied per renderer process, with the most recent\nvalue of the policy setting in force when a renderer process starts. A full\nrestart is required to ensure that all loaded tabs receive a consistent\npolicy setting. It is harmless for processes to be running with different\nvalues of this policy.\n";
IsolateOrigins.pfm_title = "Enable Site Isolation for specified origins";
IsolateOrigins.pfm_description = "Setting the policy means each of the named origins in a comma-separated list runs in its own process, and it isolates origins named by subdomains. For example, specifying https://example.com/ isolates https://foo.example.com/ as part of the https://example.com/ site.\n\nSetting it to off or leaving it unset lets users change this setting.\n\nNote: For Android, use the IsolateOriginsAndroid policy instead.";
JavaScriptAllowedForUrls.pfm_title = "Allow JavaScript on these sites";
JavaScriptAllowedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can run JavaScript.\n\nLeaving the policy unset means DefaultJavaScriptSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
JavaScriptBlockedForUrls.pfm_title = "Block JavaScript on these sites";
JavaScriptBlockedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can't run JavaScript.\n\nLeaving the policy unset means DefaultJavaScriptSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
LegacySameSiteCookieBehaviorEnabled.pfm_title = "Default legacy SameSite cookie behavior setting";
LegacySameSiteCookieBehaviorEnabled.pfm_description = "1 - Revert to legacy SameSite behavior for cookies on all sites\n2 - Use SameSite-by-default behavior for cookies on all sites\nAllows you to revert all cookies to legacy SameSite behavior. Reverting to legacy behavior causes cookies that don't specify a SameSite attribute to be treated as if they were \"SameSite=None\", removes the requirement for \"SameSite=None\" cookies to carry the \"Secure\" attribute, and skips the scheme comparison when evaluating if two sites are same-site. See https://www.chromium.org/administrators/policy-list-3/cookie-legacy-samesite-policies for full description.\n\nWhen this policy is not set, the default SameSite behavior for cookies will depend on the user's personal configuration for the SameSite-by-default feature, the Cookies-without-SameSite-must-be-secure feature, and the Schemeful Same-Site feature which may be set by a field trial or by enabling or disabling the same-site-by-default-cookies flag, the cookies-without-same-site-must-be-secure flag, or the schemeful-same-site flag, respectively.";
LegacySameSiteCookieBehaviorEnabledForDomainList.pfm_title = "Revert to legacy SameSite behavior for cookies on these sites";
LegacySameSiteCookieBehaviorEnabledForDomainList.pfm_description = "Cookies set for domains matching these patterns will revert to legacy SameSite behavior. Reverting to legacy behavior causes cookies that don't specify a SameSite attribute to be treated as if they were \"SameSite=None\", removes the requirement for \"SameSite=None\" cookies to carry the \"Secure\" attribute, and skips the scheme comparison when evaluating if two sites are same-site. See https://www.chromium.org/administrators/policy-list-3/cookie-legacy-samesite-policies for full description.\n\nFor cookies on domains not covered by the patterns specified here, or for all cookies if this policy is not set, the global default value will be used either from the LegacySameSiteCookieBehaviorEnabled policy, if it is set, or the user's personal configuration otherwise.\n\nNote that patterns you list here are treated as domains, not URLs, so you should not specify a scheme or port.";
LocalDiscoveryEnabled.pfm_title = "Enable chrome://devices";
LocalDiscoveryEnabled.pfm_description = "This policy controls access to controllable features in the local discovery UI (chrome://devices) which shows discoverable devices near the user as well as cloud devices registered to them. On all operating systems except for Chromium OS, the local discovery UI also allows users to add classic printers connected to their computers to Google Cloud Print.";
ManagedBookmarks.pfm_title = "Managed Bookmarks";
ManagedBookmarks.pfm_description = "Setting the policy sets up a list of bookmarks where each one is a dictionary with the keys \"name\" and \"url\". These keys hold the bookmark's name and target. Admins can set up a subfolder by defining a bookmark without a \"url\" key, but with an additional \"children\" key. This key also has a list of bookmarks, some of which can also be folders. Chrome amends incomplete URLs as if they were submitted through the address bar. For example, \"google.com\" becomes \"https://google.com/\".\n\nUsers can't change the folders the bookmarks are placed in (though they can hide it from the bookmark bar). The default folder name for managed bookmarks is \"Managed bookmarks\" but it can be changed by adding a new sub-dictionary to the policy with a single key named \"toplevel_name\" with the desired folder name as its value. Managed bookmarks are not synced to the user account and extensions can't modify them.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=ManagedBookmarks for more information about schema and formatting.";
MaxConnectionsPerProxy.pfm_title = "Maximal number of concurrent connections to the proxy server";
MaxConnectionsPerProxy.pfm_description = "Specifies the maximal number of simultaneous connections to the proxy server.\n\nSome proxy servers can not handle high number of concurrent connections per client and this can be solved by setting this policy to a lower value.\n\nThe value of this policy should be lower than 100 and higher than 6 and the default value is 32.\n\nSome web apps are known to consume many connections with hanging GETs, so lowering below 32 may lead to browser networking hangs if too many such web apps are open. Lower below the default at your own risk.\n\nIf this policy is left not set the default value will be used which is 32.";
MaxInvalidationFetchDelay.pfm_title = "Maximum fetch delay after a policy invalidation";
MaxInvalidationFetchDelay.pfm_description = "Specifies the maximum delay in milliseconds between receiving a policy invalidation and fetching the new policy from the device management service.\n\nSetting this policy overrides the default value of 10000 milliseconds. Valid values for this policy are in the range from 1000 (1 second) to 300000 (5 minutes). Any values not in this range will be clamped to the respective boundary.\n\nLeaving this policy not set will make Chromium use the default value of 10000 milliseconds.";
MediaRouterCastAllowAllIPs.pfm_title = "Allow Google Cast to connect to Cast devices on all IP addresses.";
MediaRouterCastAllowAllIPs.pfm_description = "Unless EnableMediaRouter is set to Disabled, setting MediaRouterCastAllowAllIPs to Enabled connects Google Cast to Cast devices on all IP addresses, not just RFC1918/RFC4193 private addresses.\n\nSetting the policy to Disabled connects Google Cast to Cast devices only on RFC1918/RFC4193.\n\nLeaving the policy unset connects Google Cast to Cast devices only on RFC1918/RFC4193, unless the CastAllowAllIPs feature is turned on.";
MetricsReportingEnabled.pfm_title = "Enable reporting of usage and crash-related data";
MetricsReportingEnabled.pfm_description = "Enables anonymous reporting of usage and crash-related data about Chromium to Google and prevents users from changing this setting.\n\nIf this setting is enabled, anonymous reporting of usage and crash-related\ndata is sent to Google.  If it is disabled, this information is not sent\nto Google.  In both cases, users cannot change or override the setting.\nIf this policy is left not set, the setting will be what the user chose\nupon installation / first run.\n\nThis policy is available only on Windows instances that are joined to a Microsoft® Active Directory® domain. or Windows 10 Pro or Enterprise instances that enrolled for device management and macOS instances that are that are managed via MDM or joined to a domain via MCX.\n\n(For Chrome OS, see DeviceMetricsReportingEnabled.)";
NTPCustomBackgroundEnabled.pfm_title = "Allow users to customize the background on the New Tab page";
NTPCustomBackgroundEnabled.pfm_description = "If the policy is set to false, the New Tab page won't allow users to customize the background. Any existing custom background will be permanently removed even if the policy is set to true later.\n\nIf the policy is set to true or unset, users can customize the background on the New Tab page.";
NativeMessagingAllowlist.pfm_title = "Names of the native messaging hosts to exempt from the blocklist";
NativeMessagingAllowlist.pfm_description = "Allows you to specify which native messaging hosts are not subject to the blocklist.\n\nA blocklist value of * means all native messaging hosts are blocked and only native messaging hosts listed in the allowlist will be loaded.\n\nBy default, all native messaging hosts are allowed, but if all native messaging hosts have been blocked by policy, the allowlist can be used to override that policy.";
NativeMessagingBlocklist.pfm_title = "Names of the forbidden native messaging hosts (or * for all)";
NativeMessagingBlocklist.pfm_description = "Allows you to specify which native messaging hosts that should not be loaded.\n\nA blocklist value of '*' means all native messaging hosts are blocked unless they are explicitly listed in the allowlist.\n\nIf this policy is left not set Chromium will load all installed native messaging hosts.";
NativeMessagingUserLevelHosts.pfm_title = "Allow user-level Native Messaging hosts (installed without admin permissions)";
NativeMessagingUserLevelHosts.pfm_description = "Enables user-level installation of Native Messaging hosts.\n\nIf this setting is enabled then Chromium allows usage of Native Messaging hosts installed on user level.\n\nIf this setting is disabled then Chromium will only use Native Messaging hosts installed on system level.\n\nIf this setting is left not set Chromium will allow usage of user-level Native Messaging hosts.";
NetworkPredictionOptions.pfm_title = "Enable network prediction";
NetworkPredictionOptions.pfm_description = "0 - Predict network actions on any network connection\n1 - Predict network actions on any network that is not cellular.\n(Deprecated in 50, removed in 52. After 52, if value 1 is set, it will be treated as 0 - predict network actions on any network connection.)\n2 - Do not predict network actions on any network connection\nEnables network prediction in Chromium and prevents users from changing this setting.\n\nThis controls DNS prefetching, TCP and SSL preconnection and prerendering of web pages.\n\nIf you set this policy, users cannot change or override this setting in Chromium.\n\nIf this policy is left not set, network prediction will be enabled but the user will be able to change it.";
NewTabPageLocation.pfm_title = "New Tab page URL";
NewTabPageLocation.pfm_description = "Configures the default New Tab page URL and prevents users from changing it.\n\nThe New Tab page is the page opened when new tabs are created (including the one opened in new windows).\n\nThis policy does not decide which pages are to be opened on start up. Those are controlled by the RestoreOnStartup policies. Yet this policy does affect the Home Page if that is set to open the New Tab page, as well as the startup page if that is set to open the New Tab page.\n\nIf the policy is not set or left empty the default new tab page is used.\n\nThis policy is available only on Windows instances that are joined to a Microsoft® Active Directory® domain. or Windows 10 Pro or Enterprise instances that enrolled for device management and macOS instances that are that are managed via MDM or joined to a domain via MCX.";
NotificationsAllowedForUrls.pfm_title = "Allow notifications on these sites";
NotificationsAllowedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can display notifications.\n\nLeaving the policy unset means DefaultJavaScriptSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
NotificationsBlockedForUrls.pfm_title = "Block notifications on these sites";
NotificationsBlockedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can't display notifications.\n\nLeaving the policy unset means DefaultJavaScriptSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
NtlmV2Enabled.pfm_title = "Enable NTLMv2 authentication.";
NtlmV2Enabled.pfm_description = "Setting the policy to Enabled or leaving it unset turns NTLMv2 on.\n\nSetting the policy to Disabled turns NTLMv2 off.\n\nAll recent versions of Samba and Microsoft® Windows® servers support NTLMv2. This should only be turned off for backward compatibility as it reduces the security of authentication.";
OverrideSecurityRestrictionsOnInsecureOrigin.pfm_title = "Origins or hostname patterns for which restrictions on\ninsecure origins should not apply";
OverrideSecurityRestrictionsOnInsecureOrigin.pfm_description = "Setting the policy specifies a list of origins (URLs) or hostname patterns (such as *.example.com) for which security restrictions on insecure origins won't apply. Organizations can set whitelist origins for legacy applications that can't deploy TLS or set up a staging server for internal web development, so developers can test out features requiring secure contexts without having to deploy TLS on the staging server. This policy also prevents the origin from being labeled \"Not Secure\" in the address bar.\n\nSetting a list of URLs in this policy amounts to setting the command-line flag --unsafely-treat-insecure-origin-as-secure to a comma-separated list of the same URLs. The policy overrides the command-line flag and UnsafelyTreatInsecureOriginAsSecure, if present.\n\nFor more information on secure contexts, see Secure Contexts ( https://www.w3.org/TR/secure-contexts ).";
PasswordLeakDetectionEnabled.pfm_title = "Enable leak detection for entered credentials";
PasswordLeakDetectionEnabled.pfm_description = "This policy can be used to force enable or force disable credential leak checking in Chromium.\n\nNote that even if this policy is set to True, the behavior will not trigger if Safe Browsing is disabled (either by policy or by the user). In order to force Safe Browsing on, use the SafeBrowsingEnabled policy.\n\nIf this policy is enabled or disabled, users cannot change or override it in Chromium. If this policy is unset, credential leak checking is allowed (but can be turned off by the user).";
PasswordManagerEnabled.pfm_title = "Enable saving passwords to the password manager";
PasswordManagerEnabled.pfm_description = "If this setting is enabled, users can have Chromium memorize passwords and provide them automatically the next time they log in to a site.\n\nIf this settings is disabled, users cannot save new passwords but they\nmay still use passwords that have been saved previously.\n\nIf this policy is enabled or disabled, users cannot change or override it in Chromium. If this policy is unset, password saving is allowed (but can be turned off by the user).";
PasswordProtectionChangePasswordURL.pfm_title = "Configure the change password URL.";
PasswordProtectionChangePasswordURL.pfm_description = "Setting the policy sets the URL for users to change their password after seeing a warning in the browser. The password protection service sends users to the URL (HTTP and HTTPS protocols only) you designate through this policy. For Chromium to correctly capture the salted hash of the new password on this change password page, make sure your change password page follows these guidelines ( https://www.chromium.org/developers/design-documents/create-amazing-password-forms ).\n\nTurning the policy off or leaving it unset means the service sends users to https://myaccount.google.com to change their password.\n\nOn Microsoft® Windows®, this functionality is only available on instances that are joined to a Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this functionality is only available on instances that are managed via MDM, or joined to a domain via MCX.";
PasswordProtectionLoginURLs.pfm_title = "Configure the list of enterprise login URLs where password protection service should capture salted hashes of passwords.";
PasswordProtectionLoginURLs.pfm_description = "Setting the policy sets the list of enterprise login URLs (HTTP and HTTPS protocols only). Password protection service will capture salted hashes of passwords on these URLs and use them for password reuse detection. For Chromium to correctly capture password salted hashes, ensure your sign-in pages follow these guidelines ( https://www.chromium.org/developers/design-documents/create-amazing-password-forms ).\n\nTurning this setting off or leaving it unset means the password protection service only captures the password salted hashes on https://accounts.google.com.\n\nOn Microsoft® Windows®, this functionality is only available on instances that are joined to a Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this functionality is only available on instances that are managed via MDM, or joined to a domain via MCX.";
PasswordProtectionWarningTrigger.pfm_title = "Password protection warning trigger";
PasswordProtectionWarningTrigger.pfm_description = "0 - Password protection warning is off\n1 - Password protection warning is triggered by password reuse\n2 - Password protection warning is triggered by password reuse on phishing page\nSetting the policy lets you control the triggering of password protection warning. Password protection alerts users when they reuse their protected password on potentially suspicious sites.\n\nUse PasswordProtectionLoginURLs and PasswordProtectionChangePasswordURL to set which password to protect.\n\nIf this policy is set to:\n\n* PasswordProtectionWarningOff, no password protection warning will be shown.\n\n* PasswordProtectionWarningOnPasswordReuse, password protection warning will be shown when the user reuses their protected password on a non-whitelisted site.\n\n* PasswordProtectionWarningOnPhishingReuse, password protection warning will be shown when the user reuses their protected password on a phishing site.\n\nLeaving the policy unset has the password protection service only protect Google passwords, but users can change this setting.";
PaymentMethodQueryEnabled.pfm_title = "Allow websites to query for available payment methods.";
PaymentMethodQueryEnabled.pfm_description = "Allows you to set whether websites are allowed to check if the user has payment methods saved.\n\nIf this policy is set to disabled, websites that use PaymentRequest.canMakePayment or PaymentRequest.hasEnrolledInstrument API will be informed that no payment methods are available.\n\nIf the setting is enabled or not set then websites are allowed to check if the user has payment methods saved.";
PluginsAllowedForUrls.pfm_title = "Allow the Flash plugin on these sites";
PluginsAllowedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can run the Flash plugin.\n\nLeaving the policy unset means DefaultPluginsSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. However, starting in M85, patterns with '*' and '[*.]' wildcards in the host are no longer supported for this policy.";
PluginsBlockedForUrls.pfm_title = "Block the Flash plugin on these sites";
PluginsBlockedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can't run the Flash plugin.\n\nLeaving the policy unset means DefaultPluginsSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. However, starting in M85, patterns with '*' and '[*.]' wildcards in the host are no longer supported for this policy.";
PolicyAtomicGroupsEnabled.pfm_title = "Enables the concept of policy atomic groups";
PolicyAtomicGroupsEnabled.pfm_description = "If this policy is enabled, policies coming from the an atomic group that do not share the source with the highest priority from that group will be ignored.\n\nIf this policy is disabled, no policy will be ignored because of its source. Policies will be ignored only if there is a conflict and the policy does not have the highest priority.\n\nIf this policy ist set from a cloud source, it cannot target a specific user";
PolicyDictionaryMultipleSourceMergeList.pfm_title = "Allow merging dictionary policies from different sources";
PolicyDictionaryMultipleSourceMergeList.pfm_description = "ContentPackManualBehaviorURLs - Managed user manual exception URLs\nDeviceLoginScreenPowerManagement - Power management on the login screen\nExtensionSettings - Extension management settings\nKeyPermissions - Key Permissions\nPowerManagementIdleSettings - Power management settings when the user becomes idle\nScreenBrightnessPercent - Screen brightness percent\nScreenLockDelays - Screen lock delays\nAllows the selected policies to be merged when they come from different sources, with the same scopes and level.\n\nThe merging consists in merging the first level keys of the dictionary from each source. In case of conflict between keys, the key coming from the highest priority source will be applied.\n\nIf a policy is in the list, in case there is conflict between two sources, given that they have the same scopes and level, the values will be merged into a new policy dictionary.\n\nIf a policy is in the list, in case there is conflict between two sources but also between different scopes and/or level, the policy with the highest priority will be applied.\n\nIf a policy is not in the list, in case there is any conflict between sources, scopes and/or level, the policy with the highest priority will be applied.";
PolicyListMultipleSourceMergeList.pfm_title = "Allow merging list policies from different sources";
PolicyListMultipleSourceMergeList.pfm_description = "Allows the selected policies to be merged when they come from different sources, with the same scopes and level.\n\nIf a policy is in the list, in case there is conflict between two sources, given that they have the same scopes and level, the values will be merged into a new policy list.\n\nIf a policy is in the list, in case there is conflict between two sources but also between different scopes and/or level, the policy with the highest priority will be applied.\n\nIf a policy is not in the list, in case there is any conflict between sources, scopes and/or level, the policy with the highest priority will be applied.";
PolicyRefreshRate.pfm_title = "Refresh rate for user policy";
PolicyRefreshRate.pfm_description = "Specifies the period in milliseconds at which the device management service is queried for user policy information.\n\nSetting this policy overrides the default value of 3 hours. Valid values for this policy are in the range from 1800000 (30 minutes) to 86400000 (1 day). Any values not in this range will be clamped to the respective boundary. If the platform supports policy notifications, the refresh delay will be set to 24 hours because it is expected that policy notifications will force a refresh automatically whenever policy changes.\n\nLeaving this policy not set will make Chromium use the default value of 3 hours.\n\nNote that if the platform supports policy notifications, the refresh delay will be set to 24 hours (ignoring all defaults and the value of this policy) because it is expected that policy notifications will force a refresh automatically whenever policy changes, making more frequent refreshes unnecessary.";
PopupsAllowedForUrls.pfm_title = "Allow popups on these sites";
PopupsAllowedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can open pop-ups.\n\nLeaving the policy unset means DefaultPopupsSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
PopupsBlockedForUrls.pfm_title = "Block popups on these sites";
PopupsBlockedForUrls.pfm_description = "Setting the policy lets you set a list of URL patterns that specify the sites that can't open pop-ups.\n\nLeaving the policy unset means DefaultPopupsSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
PrintHeaderFooter.pfm_title = "Print Headers and Footers";
PrintHeaderFooter.pfm_description = "Force 'headers and footers' to be on or off in the printing dialog.\n\nIf the policy is unset, the user can decide whether to print headers and footers.\n\nIf the policy is set to false, 'Headers and footers' is not selected in the print preview dialog, and the user cannot change it.\n\nIf the policy is set to true, 'Headers and footers' is selected in the print preview dialog, and the user cannot change it.";
PrintPreviewUseSystemDefaultPrinter.pfm_title = "Use System Default Printer as Default";
PrintPreviewUseSystemDefaultPrinter.pfm_description = "Causes Chromium to use the system default printer as the default choice in Print Preview instead of the most recently used printer.\n\nIf you disable this setting or do not set a value, Print Preview will use the most recently used printer as the default destination choice.\n\nIf you enable this setting, Print Preview will use the OS system default printer as the default destination choice.";
PrinterTypeDenyList.pfm_title = "Disable printer types on the deny list";
PrinterTypeDenyList.pfm_description = "privet - Zeroconf-based (mDNS + DNS-SD) protocol destinations\nextension - Extension-based destinations\npdf - The 'Save as PDF' destination\nlocal - Local printer destinations\ncloud - Google Cloud Print and 'Save to Google Drive' destinations\nThe printers of types placed on the deny list will be disabled from being discovered or having their capabilities fetched.\n\nPlacing all printer types on the deny list effectively disables printing, as there would be no available destinations to send a document for printing.\n\nIncluding cloud on the deny list has the same effect as setting the CloudPrintSubmitEnabled policy to false. In order to keep Google Cloud Print destinations discoverable, the CloudPrintSubmitEnabled policy must be set to true and cloud must not be on the deny list.\n\nIf the policy is not set, or is set to an empty list, all printer types will be available for discovery.\n\nExtension printers are also known as print provider destinations, and include any destination that belongs to a Chromium extension.\n\nLocal printers are also known as native printing destinations, and include destinations available to the local machine and shared network printers.";
PrintingAllowedBackgroundGraphicsModes.pfm_title = "Restrict background graphics printing mode";
PrintingAllowedBackgroundGraphicsModes.pfm_description = "any - Allow printing both with and without background graphcis\nenabled - Allow printing only with background graphics\ndisabled - Allow printing only without background graphics\nRestricts background graphics printing mode. Unset policy is treated as no restriction.";
PrintingBackgroundGraphicsDefault.pfm_title = "Default background graphics printing mode";
PrintingBackgroundGraphicsDefault.pfm_description = "enabled - Enable background graphics printing mode by default\ndisabled - Disable background graphics printing mode by default\nOverrides default background graphics printing mode.";
PrintingEnabled.pfm_title = "Enable printing";
PrintingEnabled.pfm_description = "Enables printing in Chromium and prevents users from changing this setting.\n\nIf this setting is enabled or not configured, users can print.\n\nIf this setting is disabled, users cannot print from Chromium. Printing is disabled in the wrench menu, extensions, JavaScript applications, etc. It is still possible to print from plugins that bypass Chromium while printing. For example, certain Flash applications have the print option in their context menu, which is not covered by this policy.";
PrintingPaperSizeDefault.pfm_title = "Default printing page size";
PrintingPaperSizeDefault.pfm_description = "Overrides default printing page size.\n\nname should contain one of the listed formats or 'custom' if required paper size is not in the list. If 'custom' value is provided custom_size property should be specified. It describes the desired height and width in micrometers. Otherwise custom_size property shouldn't be specified. Policy that violates these rules is ignored.\n\nIf the page size is unavailable on the printer chosen by the user this policy is ignored.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=PrintingPaperSizeDefault for more information about schema and formatting.";
PromotionalTabsEnabled.pfm_title = "Enable showing full-tab promotional content";
PromotionalTabsEnabled.pfm_description = "Setting the policy to True or leaving it unset lets Chromium show users product information as full-tab content.\n\nSetting the policy to False prevents Chromium from showing product information as full-tab content.\n\nSetting the policy controls the presentation of the welcome pages that help users sign in to Chromium, set Chromium as users' default browser, or otherwise inform them of product features.";
PromptForDownloadLocation.pfm_title = "Ask where to save each file before downloading";
PromptForDownloadLocation.pfm_description = "Setting the policy to Enabled means users are asked where to save each file before downloading. Setting the policy to Disabled has downloads start immediately, and users aren't asked where to save the file.\n\nLeaving the policy unset lets users change this setting.";
ProxyBypassList.pfm_title = "Comma-separated list of proxy bypass rules";
ProxyBypassList.pfm_description = "Chromium will bypass any proxy for the list of hosts given here.\n\nThis policy only takes effect if you have selected manual proxy settings at 'Choose how to specify proxy server settings' and if the ProxySettings policy has not been specified.\n\nYou should leave this policy not set if you have selected any other mode for setting proxy policies.\n\nFor more detailed examples, visit:\nhttps://www.chromium.org/developers/design-documents/network-settings#TOC-Command-line-options-for-proxy-sett.";
ProxyMode.pfm_title = "Choose how to specify proxy server settings";
ProxyMode.pfm_description = "direct - Never use a proxy\nauto_detect - Auto detect proxy settings\npac_script - Use a .pac proxy script\nfixed_servers - Use fixed proxy servers\nsystem - Use system proxy settings\nAllows you to specify the proxy server used by Chromium and prevents users from changing proxy settings.\n\nThis policy only takes effect if the ProxySettings policy has not been specified.\n\nIf you choose to never use a proxy server and always connect directly, all other options are ignored.\n\nIf you choose to use system proxy settings, all other options are ignored.\n\nIf you choose to auto detect the proxy server, all other options are ignored.\n\nIf you choose fixed server proxy mode, you can specify further options in 'Address or URL of proxy server' and 'Comma-separated list of proxy bypass rules'. Only the HTTP proxy server with the highest priority is available for ARC-apps.\n\nIf you choose to use a .pac proxy script, you must specify the URL to the script in 'URL to a proxy .pac file'.\n\nFor detailed examples, visit:\nhttps://www.chromium.org/developers/design-documents/network-settings#TOC-Command-line-options-for-proxy-sett.\n\nIf you enable this setting, Chromium and ARC-apps ignore all proxy-related options specified from the command line.\n\nLeaving this policy not set will allow the users to choose the proxy settings on their own.";
ProxyPacUrl.pfm_title = "URL to a proxy .pac file";
ProxyPacUrl.pfm_description = "You can specify a URL to a proxy .pac file here.\n\nThis policy only takes effect if you have selected manual proxy settings at 'Choose how to specify proxy server settings' and if the ProxySettings policy has not been specified.\n\nYou should leave this policy not set if you have selected any other mode for setting proxy policies.\n\nFor detailed examples, visit:\nhttps://www.chromium.org/developers/design-documents/network-settings#TOC-Command-line-options-for-proxy-sett.";
ProxyServer.pfm_title = "Address or URL of proxy server";
ProxyServer.pfm_description = "You can specify the URL of the proxy server here.\n\nThis policy only takes effect if you have selected manual proxy settings at 'Choose how to specify proxy server settings' and if the ProxySettings policy has not been specified.\n\nYou should leave this policy not set if you have selected any other mode for setting proxy policies.\n\nFor more options and detailed examples, visit:\nhttps://www.chromium.org/developers/design-documents/network-settings#TOC-Command-line-options-for-proxy-sett.";
ProxySettings.pfm_title = "Proxy settings";
ProxySettings.pfm_description = "Configures the proxy settings for Chromium. These proxy settings will be available for ARC-apps too.\n\nIf you enable this setting, Chromium and ARC-apps ignore all proxy-related options specified from the command line.\n\nLeaving this policy not set will allow the users to choose the proxy settings on their own.\n\nIf the ProxySettings policy is set, it will override any of the individual policies ProxyMode, ProxyPacUrl, ProxyServer, ProxyBypassList and ProxyServerMode.\n\nThe ProxyMode field allows you to specify the proxy server used by Chromium and prevents users from changing proxy settings.\n\nThe ProxyPacUrl field is a URL to a proxy .pac file.\n\nThe ProxyServer field is a URL of the proxy server.\n\nThe ProxyBypassList field is a list of proxy hosts that Chromium will bypass.\n\nThe ProxyServerMode field is deprecated in favor of the field 'ProxyMode'. It allows you to specify the proxy server used by Chromium and prevents users from changing proxy settings.\n\nIf you choose the value 'direct' as 'ProxyMode', a proxy will never be used and all other fields will be ignored.\n\nIf you choose the value 'system' as 'ProxyMode', the systems's proxy will be used and all other fields will be ignored.\n\nIf you choose the value 'auto_detect' as 'ProxyMode', all other fields will be ignored.\n\nIf you choose the value 'fixed_server' as 'ProxyMode', the 'ProxyServer' and 'ProxyBypassList' fields will be used.\n\nIf you choose the value 'pac_script' as 'ProxyMode', the 'ProxyPacUrl' and 'ProxyBypassList' fields will be used.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=ProxySettings for more information about schema and formatting.";
QuicAllowed.pfm_title = "Allow QUIC protocol";
QuicAllowed.pfm_description = "If this policy is set to true or not set usage of QUIC protocol in Chromium is allowed.\nIf this policy is set to false usage of QUIC protocol is disallowed.";
RegisteredProtocolHandlers.pfm_title = "Register protocol handlers";
RegisteredProtocolHandlers.pfm_description = "Setting the policy (as recommended only) lets you register a list of protocol handlers, which merge with the ones that the user registers, putting both sets in use. Set the property \"protocol\" to the scheme, such as \"mailto\", and set the property \"URL\" to the URL pattern of the application that handles the scheme specified in the \"protocol\" field. The pattern can include a \"%s\" placeholder, which the handled URL replaces.\n\nUsers can't remove a protocol handler registered by policy. However, by installing a new default handler, they can change the protocol handlers installed by policy.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=RegisteredProtocolHandlers for more information about schema and formatting.";
RelaunchNotification.pfm_title = "Notify a user that a browser relaunch or device restart is recommended or required";
RelaunchNotification.pfm_description = "1 - Show a recurring prompt to the user indicating that a relaunch is recommended\n2 - Show a recurring prompt to the user indicating that a relaunch is required\nNotify users that Chromium must be relaunched or Chromium OS must be restarted to apply a pending update.\n\nThis policy setting enables notifications to inform the user that a browser relaunch or device restart is recommended or required. If not set, Chromium indicates to the user that a relaunch is needed via subtle changes to its menu, while Chromium OS indicates such via a notification in the system tray. If set to 'Recommended', a recurring warning will be shown to the user that a relaunch is recommended. The user can dismiss this warning to defer the relaunch. If set to 'Required', a recurring warning will be shown to the user indicating that a browser relaunch will be forced once the notification period passes. The default period is seven days for Chromium and four days for Chromium OS, and may be configured via the RelaunchNotificationPeriod policy setting.\n\nThe user's session is restored following the relaunch/restart.";
RelaunchNotificationPeriod.pfm_title = "Time period (milliseconds)";
RelaunchNotificationPeriod.pfm_description = "Allows you to set the time period, in milliseconds, over which users are notified that Chromium must be relaunched or that a Chromium OS device must be restarted to apply a pending update.\n\nOver this time period, the user will be repeatedly informed of the need for an update. For Chromium OS devices, a restart notification appears in the system tray according to the RelaunchHeadsUpPeriod policy. For Chromium browsers, the app menu changes to indicate that a relaunch is needed once one third of the notification period passes. This notification changes color once two thirds of the notification period passes, and again once the full notification period has passed. The additional notifications enabled by the RelaunchNotification policy follow this same schedule.\n\nIf not set, the default period of 604800000 milliseconds (one week) is used.";
RemoteAccessHostAllowClientPairing.pfm_title = "Enable or disable PIN-less authentication for remote access hosts";
RemoteAccessHostAllowClientPairing.pfm_description = "If this setting is enabled or not configured, then users can opt to pair clients and hosts at connection time, eliminating the need to enter a PIN every time.\n\nIf this setting is disabled, then this feature will not be available.";
RemoteAccessHostAllowFileTransfer.pfm_title = "Allow remote access users to transfer files to/from the host";
RemoteAccessHostAllowFileTransfer.pfm_description = "Controls the ability of a user connected to a remote access host to transfer files between the client and the host. This does not apply to remote assistance connections, which do not support file transfer.\n\nIf this setting is disabled, file transfer will not be allowed. If this setting is enabled or not set, file transfer will be allowed.";
RemoteAccessHostAllowGnubbyAuth.pfm_title = "Allow gnubby authentication for remote access hosts";
RemoteAccessHostAllowGnubbyAuth.pfm_description = "If this setting is enabled, then gnubby authentication requests will be proxied across a remote host connection.\n\nIf this setting is disabled or not configured, gnubby authentication requests will not be proxied.";
RemoteAccessHostAllowRelayedConnection.pfm_title = "Enable the use of relay servers by the remote access host";
RemoteAccessHostAllowRelayedConnection.pfm_description = "Enables usage of relay servers when remote clients are trying to establish a connection to this machine.\n\nIf this setting is enabled, then remote clients can use relay servers to connect to this machine when a direct connection is not available (e.g. due to firewall restrictions).\n\nNote that if the policy RemoteAccessHostFirewallTraversal is disabled, this policy will be ignored.\n\nIf this policy is left not set the setting will be enabled.";
RemoteAccessHostClientDomainList.pfm_title = "Configure the required domain names for remote access clients";
RemoteAccessHostClientDomainList.pfm_description = "Configures the required client domain names that will be imposed on remote access clients and prevents users from changing it.\n\nIf this setting is enabled and set to one or more domains, then only clients from one of the specified domains can connect to the host.\n\nIf this setting is disabled, not set, or set to an empty list, then the default policy for the connection type is applied. For remote assistance, this allows clients from any domain to connect to the host; for anytime remote access, only the host owner can connect.\n\nThis setting will override RemoteAccessHostClientDomain, if present.\n\nSee also RemoteAccessHostDomainList.";
RemoteAccessHostDomainList.pfm_title = "Configure the required domain names for remote access hosts";
RemoteAccessHostDomainList.pfm_description = "Configures the required host domain names that will be imposed on remote access hosts and prevents users from changing it.\n\nIf this setting is enabled and set to one or more domains, then hosts can be shared only using accounts registered on one of the specified domain names.\n\nIf this setting is disabled, not set, or set to an empty list, then hosts can be shared using any account.\n\nThis setting will override RemoteAccessHostDomain, if present.\n\nSee also RemoteAccessHostClientDomainList.";
RemoteAccessHostFirewallTraversal.pfm_title = "Enable firewall traversal from remote access host";
RemoteAccessHostFirewallTraversal.pfm_description = "Enables usage of STUN servers when remote clients are trying to establish a connection to this machine.\n\nIf this setting is enabled, then remote clients can discover and connect to this machines even if they are separated by a firewall.\n\nIf this setting is disabled and outgoing UDP connections are filtered by the firewall, then this machine will only allow connections from client machines within the local network.\n\nIf this policy is left not set the setting will be enabled.";
RemoteAccessHostMatchUsername.pfm_title = "Require that the name of the local user and the remote access host owner match";
RemoteAccessHostMatchUsername.pfm_description = "If this setting is enabled, then the remote access host compares the name of the local user (that the host is associated with) and the name of the Google account registered as the host owner (i.e. \"johndoe\" if the host is owned by \"johndoe@example.com\" Google account).  The remote access host will not start if the name of the host owner is different from the name of the local user that the host is associated with.  RemoteAccessHostMatchUsername policy should be used together with RemoteAccessHostDomain to also enforce that the Google account of the host owner is associated with a specific domain (i.e. \"example.com\").\n\nIf this setting is disabled or not set, then the remote access host can be associated with any local user.";
RemoteAccessHostRequireCurtain.pfm_title = "Enable curtaining of remote access hosts";
RemoteAccessHostRequireCurtain.pfm_description = "Enables curtaining of remote access hosts while a connection is in progress.\n\nIf this setting is enabled, then hosts' physical input and output devices are disabled while a remote connection is in progress.\n\nIf this setting is disabled or not set, then both local and remote users can interact with the host when it is being shared.";
RemoteAccessHostTokenUrl.pfm_title = "URL where remote access clients should obtain their authentication token";
RemoteAccessHostTokenUrl.pfm_description = "If this policy is set, the remote access host will require authenticating clients to obtain an authentication token from this URL in order to connect. Must be used in conjunction with RemoteAccessHostTokenValidationUrl.\n\nThis feature is currently disabled server-side.";
RemoteAccessHostTokenValidationCertificateIssuer.pfm_title = "Client certificate for connecting to RemoteAccessHostTokenValidationUrl";
RemoteAccessHostTokenValidationCertificateIssuer.pfm_description = "If this policy is set, the host will use a client certificate with the given issuer CN to authenticate to RemoteAccessHostTokenValidationUrl. Set it to \"*\" to use any available client certificate.\n\nThis feature is currently disabled server-side.";
RemoteAccessHostTokenValidationUrl.pfm_title = "URL for validating remote access client authentication token";
RemoteAccessHostTokenValidationUrl.pfm_description = "If this policy is set, the remote access host will use this URL to validate authentication tokens from remote access clients, in order to accept connections. Must be used in conjunction with RemoteAccessHostTokenUrl.\n\nThis feature is currently disabled server-side.";
RemoteAccessHostUdpPortRange.pfm_title = "Restrict the UDP port range used by the remote access host";
RemoteAccessHostUdpPortRange.pfm_description = "Restricts the UDP port range used by the remote access host in this machine.\n\nIf this policy is left not set, or if it is set to an empty string, the remote access host will be allowed to use any available port, unless the policy RemoteAccessHostFirewallTraversal is disabled, in which case the remote access host will use UDP ports in the 12400-12409 range.";
RestoreOnStartup.pfm_title = "Action on startup";
RestoreOnStartup.pfm_description = "5 - Open New Tab Page\n1 - Restore the last session\n4 - Open a list of URLs\nAllows you to specify the behavior on startup.\n\nIf you choose 'Open New Tab Page' the New Tab Page will always be opened when you start Chromium.\n\nIf you choose 'Restore the last session', the URLs that were open last time Chromium was closed will be reopened and the browsing session will be restored as it was left.\nChoosing this option disables some settings that rely on sessions or that perform actions on exit (such as Clear browsing data on exit or session-only cookies).\n\nIf you choose 'Open a list of URLs', the list of 'URLs to open on startup' will be opened when a user starts Chromium.\n\nIf you enable this setting, users cannot change or override it in Chromium.\n\nDisabling this setting is equivalent to leaving it not configured. The user will still be able to change it in Chromium.\n\nThis policy is available only on Windows instances that are joined to a Microsoft® Active Directory® domain. or Windows 10 Pro or Enterprise instances that enrolled for device management and macOS instances that are that are managed via MDM or joined to a domain via MCX.";
RestoreOnStartupURLs.pfm_title = "URLs to open on startup";
RestoreOnStartupURLs.pfm_description = "If 'Open a list of URLs' is selected as the startup action, this allows you to specify the list of URLs that are opened. If left not set no URL will be opened on start up.\n\nThis policy only works if the 'RestoreOnStartup' policy is set to 'RestoreOnStartupIsURLs'.\n\nThis policy is available only on Windows instances that are joined to a Microsoft® Active Directory® domain. or Windows 10 Pro or Enterprise instances that enrolled for device management and macOS instances that are that are managed via MDM or joined to a domain via MCX.";
RestrictSigninToPattern.pfm_title = "Restrict which Google accounts are allowed to be set as browser primary accounts in Chromium";
RestrictSigninToPattern.pfm_description = "Contains a regular expression which is used to determine which Google accounts can be set as browser primary accounts in Chromium (i.e. the account that is chosen during the Sync opt-in flow).\n\nAn appropriate error is displayed if a user tries to set a browser primary account with a username that does not match this pattern.\n\nIf this policy is left not set or blank, then the user can set any Google account as a browser primary account in Chromium.";
RunAllFlashInAllowMode.pfm_title = "Extend Flash content setting to all content";
RunAllFlashInAllowMode.pfm_description = "Setting the policy to True runs all Flash content embedded on websites that allow Flash, including content from other origins or small content.\n\nSetting the policy to False or leaving it unset might block Flash content from other origins or small content.\n\nNote: To control which websites can run Flash, see these policies: DefaultPluginsSetting, PluginsAllowedForUrls, and PluginsBlockedForUrls.";
SSLErrorOverrideAllowed.pfm_title = "Allow proceeding from the SSL warning page";
SSLErrorOverrideAllowed.pfm_description = "Chrome shows a warning page when users navigate to sites that have SSL errors. By default or when this policy is set to true, users are allowed to click through these warning pages.\nSetting this policy to false disallows users to click through any warning page.";
SSLVersionMin.pfm_title = "Minimum SSL version enabled";
SSLVersionMin.pfm_description = "tls1 - TLS 1.0\ntls1.1 - TLS 1.1\ntls1.2 - TLS 1.2\nIf this policy is not configured then Chromium uses a default minimum version which is TLS 1.0.\n\nOtherwise it may be set to one of the following values: \"tls1\", \"tls1.1\" or \"tls1.2\". When set, Chromium will not use SSL/TLS versions less than the specified version. An unrecognized value will be ignored.";
SafeBrowsingAllowlistDomains.pfm_title = "Configure the list of domains on which Safe Browsing will not trigger warnings.";
SafeBrowsingAllowlistDomains.pfm_description = "Setting the policy to Enabled means Safe Browsing will trust the domains you designate. It won't check them for dangerous resources such as phishing, malware, or unwanted software. Safe Browsing's download protection service won't check downloads hosted on these domains. Its password protection service won't check for password reuse.\n\nSetting the policy to Disabled or leaving it unset means default Safe Browsing protection applies to all resources.\n\nOn Microsoft® Windows®, this functionality is only available on instances that are joined to a Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this functionality is only available on instances that are managed via MDM, or joined to a domain via MCX.";
SafeBrowsingExtendedReportingEnabled.pfm_title = "Enable Safe Browsing Extended Reporting";
SafeBrowsingExtendedReportingEnabled.pfm_description = "Setting the policy to Enabled turns on Chromium's Safe Browsing Extended Reporting, which sends some system information and page content to Google servers to help detect dangerous apps and sites.\n\nSetting the policy to Disabled means reports are never sent.\n\nIf you set this policy, users can't change it. If not set, users can decide whether to send reports or not.\n\nSee more about Safe Browsing ( https://developers.google.com/safe-browsing ).";
SafeBrowsingProtectionLevel.pfm_title = "Safe Browsing Protection Level";
SafeBrowsingProtectionLevel.pfm_description = "0 - Safe Browsing is never active.\n1 - Safe Browsing is active in the standard mode.\n2 - Safe Browsing is active in the enhanced mode. This mode provides better security, but requires sharing more browsing information with Google.\nAllows you to control whether Chromium's Safe Browsing feature is enabled and the mode it operates in.\n\nIf this policy is set to 'NoProtection' (value 0), Safe Browsing is never active.\n\nIf this policy is set to 'StandardProtection' (value 1, which is the default), Safe Browsing is always active in the standard mode.\n\nIf this policy is set to 'EnhancedProtection' (value 2), Safe Browsing is always active in the enhanced mode, which provides better security, but requires sharing more browsing information with Google.\n\nIf you set this policy as mandatory, users cannot change or override the Safe Browsing setting in Chromium.\n\nIf this policy is left not set, Safe Browsing will operate in Standard Protection mode but users can change this setting.\n\nSee https://developers.google.com/safe-browsing for more info on Safe Browsing.";
SafeSitesFilterBehavior.pfm_title = "Control SafeSites adult content filtering.";
SafeSitesFilterBehavior.pfm_description = "0 - Do not filter sites for adult content\n1 - Filter top level sites (but not embedded iframes) for adult content\nSetting the policy controls the SafeSites URL filter, which uses the Google Safe Search API to classify URLs as pornographic or not.\n\nWhen this policy is set to:\n\n* Do not filter sites for adult content, or not set, sites aren't filtered\n\n* Filter top level sites for adult content, pornographic sites are filtered";
SavingBrowserHistoryDisabled.pfm_title = "Disable saving browser history";
SavingBrowserHistoryDisabled.pfm_description = "Setting the policy to Enabled means browsing history is not saved, tab syncing is off and, and users can't change this setting.\n\nSetting the policy to Disabled or leaving it unset saves browsing history.";
ScreenCaptureAllowed.pfm_title = "Allow or deny screen capture";
ScreenCaptureAllowed.pfm_description = "If enabled or not configured (default), a Web page can use\nscreen-share APIs (e.g., getDisplayMedia() or the Desktop Capture extension API)\nto prompt the user to select a tab, window or desktop to capture.\n\nWhen this policy is disabled, any calls to screen-share APIs will fail\nwith an error.";
ScrollToTextFragmentEnabled.pfm_title = "Enable scrolling to text specified in URL fragments";
ScrollToTextFragmentEnabled.pfm_description = "This feature allows for hyperlinks and address bar URL navigations to target specific text within a web page, which will be scrolled to once the loading of the web page is complete.\n\nIf you enable or don't configure this policy, web page scrolling to specific text fragments via URL will be enabled.\n\nIf you disable this policy, web page scrolling to specific text fragments via URL will be disabled.";
SearchSuggestEnabled.pfm_title = "Enable search suggestions";
SearchSuggestEnabled.pfm_description = "Setting the policy to True turns on search suggestions in Chromium's address bar. Setting the policy to False turns off these search suggestions.\n\nIf you set the policy, users can't change it. If not set, search suggestions are on at first, but users can turn them off any time.";
SecurityKeyPermitAttestation.pfm_title = "URLs/domains automatically permitted direct Security Key attestation";
SecurityKeyPermitAttestation.pfm_description = "Specifies URLs and domains for which no prompt will be shown when attestation certificates from Security Keys are requested. Additionally, a signal will be sent to the Security Key indicating that individual attestation may be used. Without this, users will be prompted in Chrome 65+ when sites request attestation of Security Keys.\n\nURLs (like https://example.com/some/path) will only match as U2F appIDs. Domains (like example.com) only match as webauthn RP IDs. Thus, to cover both U2F and webauthn APIs for a given site, both the appID URL and domain would need to be listed.";
SerialAskForUrls.pfm_title = "Allow the Serial API on these sites";
SerialAskForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can ask users to grant them access to a serial port.\n\nLeaving the policy unset means DefaultSerialGuardSetting applies for all sites, if it's set. If not, users' personal settings apply.\n\nFor URL patterns which do not match the policy SerialBlockedForUrls (if there is a match), DefaultSerialGuardSetting (if set), or the users' personal settings take precedence, in that order.\n\nURL patterns must not conflict with SerialBlockedForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
SerialBlockedForUrls.pfm_title = "Block the Serial API on these sites";
SerialBlockedForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can't ask users to grant them access to a serial port.\n\nLeaving the policy unset means DefaultSerialGuardSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nFor URL patterns which do not match the policy SerialAskForUrls (if there is a match), DefaultSerialGuardSetting (if set), or the users' personal settings take precedence, in that order.\n\nURL patterns can't conflict with SerialAskForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
SharedClipboardEnabled.pfm_title = "Enable the Shared Clipboard Feature";
SharedClipboardEnabled.pfm_description = "Enable the Shared Clipboard feature which allows users to send text between Chrome Desktops and an Android device when Sync is enabled and the user is Signed-in.\n\nIf this policy is set to true, the capability of sending text, cross device, for chrome user is enabled.\n\nIf this policy is set to false, the capability of sending text, cross device, for chrome user is disabled.\n\nIf you set this policy, users cannot change or override it.\n\nIf this policy is left unset, the shared clipboard feature is enabled by default.\n\nIt is up to the admins to set policies in all platforms they care about. It's recommended to set this policy to one value in all platforms.";
ShowAppsShortcutInBookmarkBar.pfm_title = "Show the apps shortcut in the bookmark bar";
ShowAppsShortcutInBookmarkBar.pfm_description = "Setting the policy to True displays the apps shortcut. Setting the policy to False means this shortcut never appears.\n\nIf you set the policy, users can't change it. If not set, users decide to show or hide the apps shortcut from the bookmark bar context menu.";
ShowCastIconInToolbar.pfm_title = "Show the Google Cast toolbar icon";
ShowCastIconInToolbar.pfm_description = "Setting the policy to Enabled displays the Cast toolbar icon on the toolbar or the overflow menu, and users can't remove it.\n\nSetting the policy to Disabled or leaving it unset lets users pin or remove the icon through its contextual menu.\n\nIf the policy EnableMediaRouter is set to Disabled, then this policy's value has no effect, and the toolbar icon doesn't appear.";
ShowFullUrlsInAddressBar.pfm_title = "Show Full URLs";
ShowFullUrlsInAddressBar.pfm_description = "This feature enables display of the full URL in the address bar.\nIf this policy is set to True, then the full URL will be shown in the address bar, including schemes and subdomains.\nIf this policy is set to False, then the default URL display will apply.\nIf this policy is left unset, then the default URL display will apply and the user will be able to toggle between default and full URL display with a context menu option.\n";
ShowHomeButton.pfm_title = "Show Home button on toolbar";
ShowHomeButton.pfm_description = "Shows the Home button on Chromium's toolbar.\n\nIf you enable this setting, the Home button is always shown.\n\nIf you disable this setting, the Home button is never shown.\n\nIf you enable or disable this setting, users cannot change or override this setting in Chromium.\n\nLeaving this policy not set will allow the user to choose whether to show the home button.";
SignedHTTPExchangeEnabled.pfm_title = "Enable Signed HTTP Exchange (SXG) support";
SignedHTTPExchangeEnabled.pfm_description = "Setting the policy to True or leaving it unset means Chromium will accept web contents served as Signed HTTP Exchanges.\n\nSetting the policy to False prevents Signed HTTP Exchanges from loading.";
SitePerProcess.pfm_title = "Enable Site Isolation for every site";
SitePerProcess.pfm_description = "\nThis setting, SitePerProcess, may be used to disallow users from opting out of the default behavior of isolating all sites. Note that the IsolateOrigins policy may also be useful for isolating additional, finer-grained origins.\nIf the policy is enabled, users will be unable to opt out of the default behavior where each site runs in its own process.\nIf the policy is not configured or disabled, the user will be able to opt out of site isolation\n(e.g. using \"Disable site isolation\" entry in chrome://flags).  Setting the policy to disabled and/or not configuring the policy does not turn off Site Isolation.\nOn Chromium OS version 76 and earlier, it is recommended to also set the DeviceLoginScreenSitePerProcess device policy to the same value. If the values specified by the two policies don't match, a delay may be incurred when entering a user session while the value specified by user policy is being applied.\n\nNOTE: This policy does not apply on Android. To enable SitePerProcess on Android, use the SitePerProcessAndroid policy setting.\n";
SpellCheckServiceEnabled.pfm_title = "Enable or disable spell checking web service";
SpellCheckServiceEnabled.pfm_description = "Chromium can use a Google web service to help resolve spelling errors. If this setting is enabled, then this service is always used. If this setting is disabled, then this service is never used.\n\nSpell checking can still be performed using a downloaded dictionary; this policy only controls the usage of the online service.\n\nIf this setting is not configured then users can choose whether the spell checking service should be used or not.";
SpellcheckEnabled.pfm_title = "Enable spellcheck";
SpellcheckEnabled.pfm_description = "If this policy is not set, the user can enable or disable spellcheck in the language settings.\n\nIf this policy is set to true, spellcheck is enabled and the user cannot disable it. On Microsoft® Windows, Chromium OS and Linux, spellcheck languages can be individually toggled on or off, so the user can still effectively disable spellcheck by toggling off every spellcheck language. To avoid that, the SpellcheckLanguage policy can be used to force specific spellcheck languages to be enabled.\n\nIf this policy is set to false, spellcheck is disabled and the user cannot enable it. The SpellcheckLanguage and SpellcheckLanguageBlacklist policies have no effect when this policy is set to false.\n";
SuppressUnsupportedOSWarning.pfm_title = "Suppress the unsupported OS warning";
SuppressUnsupportedOSWarning.pfm_description = "Suppresses the warning that appears when Chromium is running on a computer or operating system that is no longer supported.\n\nIf this policy is false or unset, the warnings will appear on such unsupported computers or operating systems.";
SyncDisabled.pfm_title = "Disable synchronization of data with Google";
SyncDisabled.pfm_description = "Disables data synchronization in Chromium using Google-hosted synchronization services and prevents users from changing this setting.\n\nIf you enable this setting, users cannot change or override this setting in Chromium.\n\nIf this policy is left not set Google Sync will be available for the user to choose whether to use it or not.\n\nTo fully disable Google Sync, it is recommended that you disable the Google Sync service in the Google Admin console.\n\nThis policy should not be enabled when RoamingProfileSupportEnabled policy is set to enabled as that feature shares the same client side functionality. The Google-hosted synchronization is disabled in this case completely.";
SyncTypesListDisabled.pfm_title = "List of types that should be excluded from synchronization";
SyncTypesListDisabled.pfm_description = "If this policy is set all specified data types will be excluded from synchronization both for Google Sync as well as for roaming profile synchronization. This can be beneficial to reduce the size of the roaming profile or limit the type of data uploaded to the Google Sync Servers.\n\nThe current data types for this policy are: \"bookmarks\", \"preferences\", \"passwords\", \"autofill\", \"themes\", \"typedUrls\", \"extensions\", \"apps\", \"tabs\", \"wifiConfigurations\". Those names are case sensitive!";
TaskManagerEndProcessEnabled.pfm_title = "Enable ending processes in Task Manager";
TaskManagerEndProcessEnabled.pfm_description = "If set to false, the 'End process' button is disabled in the Task Manager.\n\nIf set to true or not configured, the user can end processes in the Task Manager.";
TotalMemoryLimitMb.pfm_title = "Set memory limit for Chrome instances";
TotalMemoryLimitMb.pfm_description = "Configures the amount of memory that a single Chromium instance can use before tabs start being discarded (I.E. the memory used by the tab will be freed and the tab will have to be reloaded when switched to) to save memory.\n\nIf the policy is set, browser will begin to discard tabs to save memory once the limitation is exceeded. However, there is no guarantee that the browser is always running under the limit. Any value under 1024 will be rounded up to 1024.\n\nIf this policy is not set, the browser will only begin attempts to save memory once it has detected that the amount of physical memory on its machine is low.";
TranslateEnabled.pfm_title = "Enable Translate";
TranslateEnabled.pfm_description = "Setting the policy to True provides translation functionality when it's appropriate for users by showing an integrated translate toolbar in Chromium and a translate option on the right-click context menu. Setting the policy to False shuts off all built-in translate features.\n\nIf you set the policy, users can't change this function. Leaving it unset lets them change the setting.";
URLAllowlist.pfm_title = "Allow access to a list of URLs";
URLAllowlist.pfm_description = "Allows access to the listed URLs, as exceptions to the URL blocklist.\n\nSee the description of the 'URLBlocklist' policy for the format of entries of this list.\n\nThis policy can be used to open exceptions to restrictive blocklists. For example, '*' can be used to block all requests, and this policy can be used to allow access to a limited list of URLs. It can be used to open exceptions to certain schemes, subdomains of other domains, ports, or specific paths.\n\nThe most specific filter will determine if a URL is blocked or allowed. The allowlist takes precedence over the blocklist.\n\nThis policy is limited to 1000 entries; subsequent entries will be ignored.\n\nThis policy also allows to enable the automatic invocation by the browser of external application registered as protocol handlers for the listed protocols like \"tel:\" or \"ssh:\". This functionality is only available for on Windows instances that are joined to a Microsoft® Active Directory® domain or Windows 10 Pro or Enterprise instances that enrolled for device management and macOS instances that are that are managed via MDM or joined to a domain via MCX.\n\nIf this policy is not set there will be no exceptions to the blocklist from the 'URLBlocklist' policy.";
URLBlocklist.pfm_title = "Block access to a list of URLs";
URLBlocklist.pfm_description = "This policy prevents the user from loading web pages from blocked URLs. The blocklist provides a list of URL patterns that specify which URLs will be blocked.\n\nA URL pattern has to be formatted according to https://www.chromium.org/administrators/url-blacklist-filter-format.\n\nExceptions can be defined in the URL allowlist policy. These policies are limited to 1000 entries; subsequent entries will be ignored.\n\nNote that it is not recommended to block internal 'chrome://*' URLs since this may lead to unexpected errors.\n\nYou can block 'javascript://*' URLs. However, it affects only JavaScript typed in address bar (or, for example, bookmarklets). Note that in-page JavaScript URLs, as long as dynamically loaded data, are not subject to this policy. For example, if you block 'example.com/abc', page 'example.com' will still be able to load 'example.com/abc' via XMLHTTPRequest.\n\nIf this policy is not set no URL will be blocked in the browser.";
UrlKeyedAnonymizedDataCollectionEnabled.pfm_title = "Enable URL-keyed anonymized data collection";
UrlKeyedAnonymizedDataCollectionEnabled.pfm_description = "Enable URL-keyed anonymized data collection in Chromium and prevents users from changing this setting.\n\nURL-keyed anonymized data collection sends URLs of pages the user visits to Google to make searches and browsing better.\n\nIf you enable this policy, URL-keyed anonymized data collection is always active.\n\nIf you disable this policy, URL-keyed anonymized data collection is never active.\n\nIf this policy is left not set, URL-keyed anonymized data collection will be enabled but the user will be able to change it.";
UserAgentClientHintsEnabled.pfm_title = "Control the User-Agent Client Hints feature.";
UserAgentClientHintsEnabled.pfm_description = "When enabled the User-Agent Client Hints feature sends granular request headers providing information about the user browser and environment.\n\nThis is an additive feature, but the new headers may break some websites that restrict the characters that requests may contain.\n\nIf this policy is enabled or not set the User-Agent Client Hints feature is enabled. If the policy is disabled the feature is unavailable.\n\nThis enterprise policy is for short-term adaptation and will be removed in Chrome 88.";
UserDataDir.pfm_title = "Set user data directory";
UserDataDir.pfm_description = "Configures the directory that Chromium will use for storing user data.\n\nIf you set this policy, Chromium will use the provided directory regardless whether the user has specified the '--user-data-dir' flag or not. To avoid data loss or other unexpected errors this policy should not be set to a directory used for other purposes, because Chromium manages its contents.\n\nSee https://support.google.com/chrome/a?p=Supported_directory_variables for a list of variables that can be used.\n\nIf this policy is left not set the default profile path will be used and the user will be able to override it with the '--user-data-dir' command line flag.";
UserDataSnapshotRetentionLimit.pfm_title = "Limits the number of user data snapshots retained for use in case of emergency rollback.";
UserDataSnapshotRetentionLimit.pfm_description = "Following each major version update, Chrome will create a snapshot of certain portions of the user's browsing data for use in case of a later emergency version rollback. If an emergency rollback is performed to a version for which a user has a corresponding snapshot, the data in the snapshot is restored. This allows users to retain such settings as bookmarks and autofill data.\n\nIf this policy is not set, the default value of 3 is used\n\nIf the policy is set, old snapshots are deleted as needed to respect the limit. If the policy is set to 0, no snapshots will be taken";
UserFeedbackAllowed.pfm_title = "Allow user feedback";
UserFeedbackAllowed.pfm_description = "Allow user feedback.\nIf the policy is set to false, users can not send feedback to Google.\n\nIf the policy is unset or set to true, users can send feedback to Google via Menu->Help->Report an Issue or key combination.";
VideoCaptureAllowed.pfm_title = "Allow or deny video capture";
VideoCaptureAllowed.pfm_description = "Setting the policy to Enabled or leaving it unset means that, with the exception of URLs set in the VideoCaptureAllowedUrls list, users get prompted for video capture access.\n\nSetting the policy to Disabled turns off prompts, and video capture is only available to URLs set in the VideoCaptureAllowedUrls list.\n\nNote: The policy affects all video input (not just the built-in camera).";
VideoCaptureAllowedUrls.pfm_title = "URLs that will be granted access to video capture devices without prompt";
VideoCaptureAllowedUrls.pfm_description = "Setting the policy means you specify the URL list whose patterns get matched to the security origin of the requesting URL. A match grants access to video capture devices without prompt\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
WPADQuickCheckEnabled.pfm_title = "Enable WPAD optimization";
WPADQuickCheckEnabled.pfm_description = "Allows to turn off WPAD (Web Proxy Auto-Discovery) optimization in Chromium.\n\nIf this policy is set to false, WPAD optimization is disabled causing Chromium to wait longer for DNS-based WPAD servers.  If the policy is not set or is enabled, WPAD optimization is enabled.\n\nIndependent of whether or how this policy is set, the WPAD optimization setting cannot be changed by users.";
WebAppInstallForceList.pfm_title = "URLs for Web Apps to be silently installed.";
WebAppInstallForceList.pfm_description = "Setting the policy specifies a list of web apps that install silently, without user interaction, and which users can't uninstall or turn off.\n\nEach list item of the policy is an object with a mandatory member: url (the URL of the web app to install) and 2 optional members: default_launch_container (for how the web app opens—a new tab is the default) and create_desktop_shortcut (True if you want to create Linux and Windows® desktop shortcuts).\n\nSee PinnedLauncherApps for pinning apps to the Chromium OS shelf.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=WebAppInstallForceList for more information about schema and formatting.";
WebRtcEventLogCollectionAllowed.pfm_title = "Allow collection of WebRTC event logs from Google services";
WebRtcEventLogCollectionAllowed.pfm_description = "\nSetting the policy to True allows Chromium to collect WebRTC event logs from Google services such as Hangouts Meet and upload them to Google. These logs have diagnostic information for debugging issues with audio or video meetings in Chromium, such as the time and size of RTP packets, feedback about congestion on the network, and metadata about time and quality of audio and video frames. These logs have no audio or video content from the meeting. To make debugging easier, Google might associate these logs, by means of a session ID, with other logs collected by the Google service itself.\n\nSetting the policy to False results in no collection or uploading of such logs.\n\nLeaving the policy unset on versions up to and including M76 means Chromium defaults to not being able to collect and upload these logs. Starting at M77, Chromium defaults to being able to collect and upload these logs from most profiles affected by cloud-based user-level enterprise policies. From M77 up to and including M80, Chromium can also collect and upload these logs by default from profiles affected by Chromium on-premise management.";
WebRtcLocalIpsAllowedUrls.pfm_title = "URLs for which local IPs are exposed in WebRTC ICE candidates";
WebRtcLocalIpsAllowedUrls.pfm_description = "Patterns in this list will be matched against the security origin of the requesting URL.\nIf a match is found or chrome://flags/#enable-webrtc-hide-local-ips-with-mdns is Disabled, the local IP addresses are shown in WebRTC ICE candidates.\nOtherwise, local IP addresses are concealed with mDNS hostnames.\nPlease note that this policy weakens the protection of local IPs if needed by administrators.";
WebRtcUdpPortRange.pfm_title = "Restrict the range of local UDP ports used by WebRTC";
WebRtcUdpPortRange.pfm_description = "If the policy is set, the UDP port range used by WebRTC is restricted to the specified port interval (endpoints included).\n\nIf the policy is not set, or if it is set to the empty string or an invalid port range, WebRTC is allowed to use any available local UDP port.";
WebUsbAllowDevicesForUrls.pfm_title = "Automatically grant permission to these sites to connect to USB devices with the given vendor and product IDs.";
WebUsbAllowDevicesForUrls.pfm_description = "Setting the policy lets you make a list of URL patterns that specify which sites are automatically granted permission to access a USB device with the given vendor and product IDs. Each list item must have devices and URLs for the policy to be valid. Each item in devices can have a vendor ID and product ID field. Any ID you omit is treated as a wildcard with one exception: You can't specify a product ID without also specifying a vendor ID. Otherwise, the policy won't be valid.\n\nThe USB permission model uses the requesting URL and the embedding URL (of the top-level frame site) to permit the requesting URL to access the USB device. The requesting URL might differ from the embedding URL when the requesting site loads in an iframe. So, the \"urls\" field can contain up to 2 strings delimited by a comma to specify these URLs. If you only specify one, then access to the corresponding USB devices is granted when the requesting site's URL matches this URL, regardless of embedding status. The URLs in \"urls\" must be valid URLs, or the policy is ignored.\n\nLeaving the policy unset means DefaultWebUsbGuardSetting applies, if it's set. If not, the user's personal setting applies.\n\nURL patterns in this policy shouldn't conflict with those configured through WebUsbBlockedForUrls. If they do, this policy takes precedence over WebUsbBlockedForUrls and WebUsbAskForUrls.\n\nValues for this policy and DeviceWebUsbAllowDevicesForUrls merge.\nSee https://cloud.google.com/docs/chrome-enterprise/policies/?policy=WebUsbAllowDevicesForUrls for more information about schema and formatting.";
WebUsbAskForUrls.pfm_title = "Allow WebUSB on these sites";
WebUsbAskForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can ask users to grant them access to a USB device.\n\nLeaving the policy unset means DefaultWebUsbGuardSetting applies for all sites, if it's set. If not, users' personal settings apply.\n\nURL patterns must not conflict with WebUsbAskForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";
WebUsbBlockedForUrls.pfm_title = "Block WebUSB on these sites";
WebUsbBlockedForUrls.pfm_description = "Setting the policy lets you list the URL patterns that specify which sites can't ask users to grant them access to a USB device.\n\nLeaving the policy unset means DefaultWebUsbGuardSetting applies for all sites, if it's set. If not, the user's personal setting applies.\n\nURL patterns can't conflict with WebUsbAskForUrls. Neither policy takes precedence if a URL matches with both.\n\nFor detailed information on valid url patterns, please see https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.";